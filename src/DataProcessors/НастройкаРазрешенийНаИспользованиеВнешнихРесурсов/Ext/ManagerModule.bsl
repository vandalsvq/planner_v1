////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Клиентские процедуры и функции общего назначения:
// - Поддержка профилей безопасности
//
////////////////////////////////////////////////////////////////////////////////

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Создание запросов разрешений
//

// Создает запрос на изменение разрешений использования внешних ресурсов.
// Только для внутреннего использования.
//
// Параметры:
//  Владелец - ЛюбаяСсылка - владелец разрешений на использование внешних ресурсов
//    (Неопределено при запросе разрешений для конфигурации, а не для объектов конфигурации),
//  РежимЗамещения - Булево - режим замещения ранее предоставленных для владельца разрешений,
//  ДобавляемыеРазрешения - Массив(ОбъектXDTO) - массив ОбъектовXDTO, соответствующих внутренним описаниям
//    запрашиваемых разрешений на доступ к внешним ресурсам. Предполагается, что все ОбъектыXDTO, передаваемые
//    в качестве параметра, сформированы с помощью вызова функций РаботаВБезопасномРежиме.Разрешение*(),
//  УдаляемыеРазрешения - Массив(ОбъектXDTO) - массив ОбъектовXDTO, соответствующих внутренним описаниям
//    отменяемых разрешений на доступ к внешним ресурсам. Предполагается, что все ОбъектыXDTO, передаваемые
//    в качестве параметра, сформированы с помощью вызова функций РаботаВБезопасномРежиме.Разрешение*(),
//  ВнешнийМодуль - ЛюбаяСсылка - ссылка, соответствующая внешнему модулю, для которого запрашиваются
//    разрешения. (Неопределено при запросе разрешений для конфигурации, а не для внешних модулей).
//
// Возвращаемое значение - УникальныйИдентификатор - идентификатор созданного запроса.
//
Функция ЗапросНаИзменениеРазрешенийИспользованияВнешнихРесурсов(Знач Владелец, Знач РежимЗамещения, Знач ДобавляемыеРазрешения = Неопределено, Знач УдаляемыеРазрешения = Неопределено, Знач ВнешнийМодуль = Неопределено) Экспорт
	
	Если Не ТребуетсяЗапросРазрешенийНаИспользованиеВнешнихРесурсов() Тогда
		Возврат Новый УникальныйИдентификатор();
	КонецЕсли;
	
	Если Владелец = Неопределено Тогда
		Владелец = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
	КонецЕсли;
	
	Если ВнешнийМодуль = Неопределено Тогда
		ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
	КонецЕсли;
	
	Если РаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
		БезопасныйРежим = БезопасныйРежим();
	Иначе
		БезопасныйРежим = Ложь;
	КонецЕсли;
	
	Менеджер = РегистрыСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов.СоздатьМенеджерЗаписи();
	Менеджер.ИдентификаторЗапроса = Новый УникальныйИдентификатор();
	Менеджер.МоментВремени = ТекущаяУниверсальнаяДата();
	Менеджер.БезопасныйРежим = БезопасныйРежим;
	Менеджер.РежимЗамещения = РежимЗамещения;
	Менеджер.Состояние = Перечисления.СостоянияЗапросовНаИспользованиеВнешнихРесурсов.Новый;
	
	СвойстваВладельца = СвойстваДляРегистраРазрешений(Владелец);
	Менеджер.ТипВладельца = СвойстваВладельца.Тип;
	Менеджер.ИдентификаторВладельца = СвойстваВладельца.Идентификатор;
	
	СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ВнешнийМодуль);
	Менеджер.ТипПрограммногоМодуля = СвойстваПрограммногоМодуля.Тип;
	Менеджер.ИдентификаторПрограммногоМодуля = СвойстваПрограммногоМодуля.Идентификатор;
	
	Если ДобавляемыеРазрешения <> Неопределено Тогда
		
		МассивРазрешений = Новый Массив();
		Для Каждого НовоеРазрешение Из ДобавляемыеРазрешения Цикл
			МассивРазрешений.Добавить(ОбщегоНазначения.ОбъектXDTOВСтрокуXML(НовоеРазрешение));
		КонецЦикла;
		
		Если МассивРазрешений.Количество() > 0 Тогда
			Менеджер.ДобавляемыеРазрешения = ОбщегоНазначения.ЗначениеВСтрокуXML(МассивРазрешений);
		КонецЕсли;
		
	КонецЕсли;
	
	Если УдаляемыеРазрешения <> Неопределено Тогда
		
		МассивРазрешений = Новый Массив();
		Для Каждого ОтменяемоеРазрешение Из УдаляемыеРазрешения Цикл
			МассивРазрешений.Добавить(ОбщегоНазначения.ОбъектXDTOВСтрокуXML(ОтменяемоеРазрешение));
		КонецЦикла;
		
		Если МассивРазрешений.Количество() > 0 Тогда
			Менеджер.УдаляемыеРазрешения = ОбщегоНазначения.ЗначениеВСтрокуXML(МассивРазрешений);
		КонецЕсли;
		
	КонецЕсли;
	
	Менеджер.Записать();
	
	Возврат Менеджер.ИдентификаторЗапроса;
	
КонецФункции

// Создает запрос на администрирование разрешений использования внешних ресурсов (создание /
// удаление профилей безопасности, назначение профилей безопасности для ИБ и т.д.).
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка - ссылка, соответствующая внешнему модулю, для которого запрашиваются
//    разрешения. (Неопределено при запросе разрешений для конфигурации, а не для внешних модулей),
//  Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которая должна быть выполнена
//    при администрировании запроса разрешений.
//
// Возвращаемое значение - УникальныйИдентификатор - идентификатор созданного запроса.
//
Функция ЗапросНаАдминистрированиеРазрешенийИспользованияВнешнихРесурсов(Знач ВнешнийМодуль, Знач Операция) Экспорт
	
	Если Не ТребуетсяЗапросРазрешенийНаИспользованиеВнешнихРесурсов() Тогда
		Возврат Новый УникальныйИдентификатор();
	КонецЕсли;
	
	Если Операция = Перечисления.ОперацииСНаборамиРазрешений.Создание Тогда
		ИмяПрофиляБезопасности = НовоеИмяПрофиляБезопасности(ВнешнийМодуль);
	Иначе
		ИмяПрофиляБезопасности = ИмяПрофиляБезопасности(ВнешнийМодуль);
	КонецЕсли;
	
	Менеджер = РегистрыСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов.СоздатьМенеджерЗаписи();
	Менеджер.ИдентификаторЗапроса = Новый УникальныйИдентификатор();
	Менеджер.Операция = Операция;
	Менеджер.МоментВремени = ТекущаяУниверсальнаяДата();
	Менеджер.Состояние = Перечисления.СостоянияЗапросовНаИспользованиеВнешнихРесурсов.Новый;
	Менеджер.Имя = ИмяПрофиляБезопасности;
	
	СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ВнешнийМодуль);
	Менеджер.ТипПрограммногоМодуля = СвойстваПрограммногоМодуля.Тип;
	Менеджер.ИдентификаторПрограммногоМодуля = СвойстваПрограммногоМодуля.Идентификатор;
	
	Менеджер.Записать();
	
	Возврат Менеджер.ИдентификаторЗапроса;
	
КонецФункции

// Создает запросы на отключение использования профилей безопасности.
//
// Параметры:
//  ВключаяПрофильИБ - Булево - если Ложь - то будут созданы запросы только для удаления профилей безопасности
//   внешних модулей.
//
// Возвращаемое значение: Массив(УникальныйИдентификатор) - идентификаторы запросов для отключения профилей безопасности.
//
Функция ЗапросыНаОтключениеПрофилейБезопасности(Знач ВключаяПрофильИБ = Истина)
	
	Результат = Новый Массив();
	
	НачатьТранзакцию();
	
	Попытка
		
		Если ВключаяПрофильИБ Тогда
			
			ИдентификаторЗапросаУдаленияПрофиляИБ = РаботаВБезопасномРежимеСлужебный.ЗапросНаУдалениеНабораРазрешений(
				Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
			
			Результат.Добавить(ИдентификаторЗапросаУдаленияПрофиляИБ);
			
		КонецЕсли;
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	РежимыПодключенияВнешнихМодулей.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
			|	РежимыПодключенияВнешнихМодулей.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля
			|ИЗ
			|	РегистрСведений.РежимыПодключенияВнешнихМодулей КАК РежимыПодключенияВнешнихМодулей";
		Запрос = Новый Запрос(ТекстЗапроса);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Результат.Добавить(РаботаВБезопасномРежимеСлужебный.ЗапросНаУдалениеНабораРазрешений(
				СсылкаИзРегистраРазрешений(Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля)));
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Создает "пустые" запросы замещения для всех ранее предоставленных разрешений.
//
// Возвращаемое значение: Массив(УникальныйИдентификатор) - идентификаторы запросов для замещения всех ранее предоставленных разрешений.
//
Функция ЗапросыЗамещенияДляВсехПредоставленныхРазрешений()
	
	Результат = Новый Массив();
	
	МенеджерыРегистров = МенеджерыРегистровРазрешений();
	
	ШаблонЗапросаКТаблицеРегистра = "ВЫБРАТЬ РАЗЛИЧНЫЕ ТаблицаРазрешений.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля, ТаблицаРазрешений.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля, ТаблицаРазрешений.ТипВладельца КАК ТипВладельца, ТаблицаРазрешений.ИдентификаторВладельца КАК ИдентификаторВладельца ИЗ %1 КАК ТаблицаРазрешений";
	ТекстЗапросаКТаблицамРегистров = "";
	
	Для Каждого МенеджерРегистра Из МенеджерыРегистров Цикл
		
		ОбъектМетаданных = МенеджерРегистра.СоздатьНаборЗаписей().Метаданные();
		
		Если Не ПустаяСтрока(ТекстЗапросаКТаблицамРегистров) Тогда
			ТекстЗапросаКТаблицамРегистров = ТекстЗапросаКТаблицамРегистров + " ОБЪЕДИНИТЬ ВСЕ ";
		КонецЕсли;
		
		ТекстЗапросаКТаблицамРегистров = ТекстЗапросаКТаблицамРегистров + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонЗапросаКТаблицеРегистра, ОбъектМетаданных.ПолноеИмя());
		
	КонецЦикла;
	
	ТекстЗапроса = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"ВЫБРАТЬ РАЗЛИЧНЫЕ ВложенныйЗапрос.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля, ВложенныйЗапрос.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля, ВложенныйЗапрос.ТипВладельца КАК ТипВладельца, ВложенныйЗапрос.ИдентификаторВладельца КАК ИдентификаторВладельца  ИЗ (%1) КАК ВложенныйЗапрос",
		ТекстЗапросаКТаблицамРегистров);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ПрограммныйМодуль = СсылкаИзРегистраРазрешений(
			Выборка.ТипПрограммногоМодуля,
			Выборка.ИдентификаторПрограммногоМодуля);
		
		Владелец = СсылкаИзРегистраРазрешений(
			Выборка.ТипВладельца,
			Выборка.ИдентификаторВладельца);
		
		ЗапросЗамещения = РаботаВБезопасномРежимеСлужебный.ЗапросНаИзменениеРазрешенийИспользованияВнешнихРесурсов(
			Владелец, Истина, Новый Массив(), , ПрограммныйМодуль);
		
		Результат.Добавить(ЗапросЗамещения);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет необходимость интерактивного запроса разрешений на использование внешних ресурсов.
//
// Возвращаемое значение: Булево.
//
Функция ТребуетсяЗапросРазрешенийНаИспользованиеВнешнихРесурсов()
	
	Если Не ВозможенЗапросРазрешенийНаИспользованиеВнешнихРесурсов() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Константы.ИспользуютсяПрофилиБезопасности.Получить() И Константы.АвтоматическиНастраиватьРазрешенияВПрофиляхБезопасности.Получить();
	
КонецФункции

// Проверяет возможность интерактивного запроса разрешений на использование внешних ресурсов.
//
// Возвращаемое значение: Булево.
//
Функция ВозможенЗапросРазрешенийНаИспользованиеВнешнихРесурсов()
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) ИЛИ Не ПолучитьФункциональнуюОпцию("ИспользуютсяПрофилиБезопасности") Тогда
		
		// В файловой ИБ или при выключенных профилях безопасности запись запросов разрешений возможна
		// в привилегированном режиме или при использовании учетной записи пользователя с правами администратора.
		Возврат ПривилегированныйРежим() ИЛИ Пользователи.ЭтоПолноправныйПользователь();
		
	Иначе
		
		// В клиент-серверной ИБ при включенных профилях безопасности запись запросов разрешений доступна только
		// администраторам независимо от установки привилегированного режима.
		Если Не Пользователи.ЭтоПолноправныйПользователь() Тогда
			
			ВызватьИсключение НСтр("ru = 'Недостаточно прав доступа для запроса разрешений на использование внешних ресурсов!'");
			
		КонецЕсли;
		
		Возврат Истина;
		
	КонецЕсли; 
	
КонецФункции

// Очищает просроченные запросы на использование внешних ресурсов.
//
Процедура ОчисткаНеактуальныхЗапросовНаИспользованиеВнешнихРесурсов() Экспорт
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	Запросы.ИдентификаторЗапроса КАК ИдентификаторЗапроса,
		|	Запросы.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
		|	Запросы.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля,
		|	Запросы.ТипВладельца КАК ТипВладельца,
		|	Запросы.ИдентификаторВладельца КАК ИдентификаторВладельца,
		|	Запросы.БезопасныйРежим КАК БезопасныйРежим
		|ИЗ
		|	РегистрСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов КАК Запросы
		|ГДЕ
		|	Запросы.МоментВремени <= &ДатаЗапроса";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДатаЗапроса", ТекущаяУниверсальнаяДата() - 3600); // Время жизни запроса - час
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		НачатьТранзакцию();
		
		Попытка
			
			Ключ = РегистрыСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов.СоздатьКлючЗаписи(
				Новый Структура("ИдентификаторЗапроса, ТипПрограммногоМодуля, ИдентификаторПрограммногоМодуля, ТипВладельца, ИдентификаторВладельца, БезопасныйРежим",
				Выборка.ИдентификаторЗапроса,
				Выборка.ТипПрограммногоМодуля,
				Выборка.ИдентификаторПрограммногоМодуля,
				Выборка.ТипВладельца,
				Выборка.ИдентификаторВладельца,
				Выборка.БезопасныйРежим));
			ЗаблокироватьДанныеДляРедактирования(Ключ);
			
		Исключение
			
			// Обработка исключения не требуется.
			// Ожидаемое исключение - попытка удалить ту же запись регистра из другого сеанса.
			ОтменитьТранзакцию();
			Продолжить;
			
		КонецПопытки;
		
		Набор = РегистрыСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов.СоздатьНаборЗаписей();
		Набор.Отбор.ИдентификаторЗапроса.Установить(Выборка.ИдентификаторЗапроса);
		Набор.Записать();
		
		ЗафиксироватьТранзакцию();
		
	КонецЦикла;
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	Запросы.ИдентификаторЗапроса КАК ИдентификаторЗапроса,
		|	Запросы.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
		|	Запросы.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля
		|ИЗ
		|	РегистрСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов КАК Запросы
		|ГДЕ
		|	Запросы.МоментВремени <= &ДатаЗапроса";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДатаЗапроса", ТекущаяУниверсальнаяДата() - 3600); // Время жизни запроса - час
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		НачатьТранзакцию();
		
		Попытка
			
			Ключ = РегистрыСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов.СоздатьКлючЗаписи(
				Новый Структура("ИдентификаторЗапроса, ТипПрограммногоМодуля, ИдентификаторПрограммногоМодуля",
				Выборка.ИдентификаторЗапроса, Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля));
			ЗаблокироватьДанныеДляРедактирования(Ключ);
			
		Исключение
			
			// Обработка исключения не требуется.
			// Ожидаемое исключение - попытка удалить ту же запись регистра из другого сеанса.
			ОтменитьТранзакцию();
			Продолжить;
			
		КонецПопытки;
		
		Набор = РегистрыСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов.СоздатьНаборЗаписей();
		Набор.Отбор.ИдентификаторЗапроса.Установить(Выборка.ИдентификаторЗапроса);
		Набор.Записать();
		
		ЗафиксироватьТранзакцию();
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с таблицами разрешений
//

// Возвращает структуру, содержащую таблицы разрешений на использование внешних ресурсов.
//
// Вовзращаемое значение: Структура:
//                          * Ключ - Строка, имя XDTO-типа, описывающего тип разрешения,
//                          * Значение - ТаблицаЗначений, структура колонок совпадает с набором
//                              полей регистра сведений, который используется для хранения
//                              перечня предоставленных разрешений данного типа (см. МенеджерыРегистровРазрешений()).
//
Функция ТаблицыРазрешений() Экспорт
	
	Результат = Новый Структура();
	
	Менеджеры = МенеджерыРегистровРазрешений();
	
	Для Каждого Менеджер Из Менеджеры Цикл
		
		МетаданныеРегистра = Менеджер.СоздатьНаборЗаписей().Метаданные();
		Таблица = ТаблицаРазрешений(МетаданныеРегистра);
		Результат.Вставить(Менеджер.ТипXDTOПредставленияРазрешений().Имя, Таблица);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает таблицу, подходящую для хранения перечня предоставленных разрешений определенного типа.
//
// Параметры:
//  МетаданныеРегистра - ОбъектМетаданных(РегистрСведений) - объект метаданных, соответствующий регистру
//    сведений, использующемуся для хранения перечня предоставленных разрешений определенного типа (см.
//    МенеджерыРегистровРазрешений()),
//  ИндексироватьИзмерения - Булево - флаг необходимости индексации колонок таблицы, соответствующих
//    измерениям регистра.
//
// Возвращаемое значение: ТаблицаЗначений, состав колонок которой соответствует составу полей регистра сведений,
//  использующегося для хранения перечня предоставленных разрешений определенного типа.
//
Функция ТаблицаРазрешений(Знач МетаданныеРегистра, Знач ИндексироватьИзмерения = Ложь) Экспорт
	
	Таблица = Новый ТаблицаЗначений();
	ПоляИндекса = Новый Массив();
	
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Таблица.Колонки.Добавить(Измерение.Имя, Измерение.Тип);
		Если ИндексироватьИзмерения Тогда
			ПоляИндекса.Добавить(Измерение.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Ресурс Из МетаданныеРегистра.Ресурсы Цикл
		Таблица.Колонки.Добавить(Ресурс.Имя, Ресурс.Тип);
	КонецЦикла;
	
	Для Каждого Реквизит Из МетаданныеРегистра.Реквизиты Цикл
		Таблица.Колонки.Добавить(Реквизит.Имя, Реквизит.Тип);
	КонецЦикла;
	
	Если ПоляИндекса.Количество() > 0 Тогда
		Таблица.Индексы.Добавить(СтроковыеФункцииКлиентСервер.СтрокаИзМассиваПодстрок(ПоляИндекса, ", "));
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Возвращает количество разрешений в таблицах разрешений.
//
// Параметры:
//  Таблицы - Структура - таблицы разрешений, в которых анализируется количество
//    (см. ТаблицыРазрешений()).
//
// Возвращаемое значение: Число - количество разрешений в таблицах.
//
Функция КоличествоРазрешенийВТаблицах(Знач Таблицы) Экспорт
	
	Результат = 0;
	
	Для Каждого КлючИЗначение Из Таблицы Цикл
		Результат = Результат + КлючИЗначение.Значение.Количество();
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с регистрами хранения разрешений
//

// Возвраает массив менеджеров регистров сведений, которые используются для хранения перечня предоставленных
// разрешений.
//
// Возвращаемое значение: Массив(РегистрСведенийМенеджер).
//
Функция МенеджерыРегистровРазрешений() Экспорт
	
	Результат = Новый Массив();
	
	Результат.Добавить(РегистрыСведений.РазрешенныеКаталогиФайловойСистемы);
	Результат.Добавить(РегистрыСведений.РазрешенныеCOMКлассы);
	Результат.Добавить(РегистрыСведений.РазрешенныеВнешниеКомпоненты);
	Результат.Добавить(РегистрыСведений.РазрешенныеПриложенияОперационнойСистемы);
	Результат.Добавить(РегистрыСведений.РазрешенныеИнтернетРесурсы);
	Результат.Добавить(РегистрыСведений.РазрешенияПереходаВПривилегированныйРежим);
	
	Возврат Результат;
	
КонецФункции

// Устанавливает исключительную управляемую блокировку на теаблицы всех регистров, использующихся
// для хранения перечня предоставленных разрешений.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка, ссылка на элемент справочника, соответствующая внешнему модулю, информацию
//    о ранее предоставленных разрешениях по которому требуется очистить. Если значение параметра не задано -
//    будет заблокирована информация о предоставленных разрешениях по всем внешним модулям.
// ЗаблокироватьРежимыПодключенияВнешнихМодулей - Булево, флаг необходимости дополнительной блокировки режимов подключения
//    внешних модулей.
//
Процедура ЗаблокироватьРегистрыПредоставленныхРазрешений(Знач ВнешнийМодуль = Неопределено, Знач ЗаблокироватьРежимыПодключенияВнешнихМодулей = Истина)
	
	Если Не ТранзакцияАктивна() Тогда
		ВызватьИсключение НСтр("ru = 'Транзакция не активна!'");
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных();
	
	Регистры = МенеджерыРегистровРазрешений();
	
	Если ЗаблокироватьРежимыПодключенияВнешнихМодулей Тогда
		Регистры.Добавить(РегистрыСведений.РежимыПодключенияВнешнихМодулей);
	КонецЕсли;
	
	Для Каждого Регистр Из Регистры Цикл
		БлокировкаРегистра = Блокировка.Добавить(Регистр.СоздатьНаборЗаписей().Метаданные().ПолноеИмя());
		Если ВнешнийМодуль <> Неопределено Тогда
			СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ВнешнийМодуль);
			БлокировкаРегистра.УстановитьЗначение("ТипПрограммногоМодуля", СвойстваПрограммногоМодуля.Тип);
			БлокировкаРегистра.УстановитьЗначение("ИдентификаторПрограммногоМодуля", СвойстваПрограммногоМодуля.Идентификатор);
		КонецЕсли;
	КонецЦикла;
	
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Очищает регистры сведений, которые используются для хранения в ИБ перечня предоставленных разрешений.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка, ссылка на элемент справочника, соответствующая внешнему модулю, информацию
//    о ранее предоставленных разрешениях по которому требуется очистить. Если значение параметра не задано -
//    будет очищена информация о предоставленных разрешениях по всем внешним модулям.
// ОчиститьРежимыПодключенияВнешнихМодулей - Булево, флаг необходимости дополнительной очистки режимов подключения
//    внешних модулей.
//
Процедура ОчиститьПредоставленныеРазрешения(Знач ВнешнийМодуль = Неопределено, Знач ОчиститьРежимыПодключенияВнешнихМодулей = Истина) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		ЗаблокироватьРегистрыПредоставленныхРазрешений(ВнешнийМодуль, ОчиститьРежимыПодключенияВнешнихМодулей);
		
		Менеджеры = МенеджерыРегистровРазрешений();
		
		Если ОчиститьРежимыПодключенияВнешнихМодулей Тогда
			Менеджеры.Добавить(РегистрыСведений.РежимыПодключенияВнешнихМодулей);
		КонецЕсли;
		
		Для Каждого Менеджер Из Менеджеры Цикл
			Набор = Менеджер.СоздатьНаборЗаписей();
			Если ВнешнийМодуль <> Неопределено Тогда
				СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ВнешнийМодуль);
				Набор.Отбор.ТипПрограммногоМодуля.Установить(СвойстваПрограммногоМодуля.Тип);
				Набор.Отбор.ИдентификаторПрограммногоМодуля.Установить(СвойстваПрограммногоМодуля.Идентификатор);
			КонецЕсли;
			Набор.Записать(Истина);
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Возвращает текущий срез предоставленных разрешений на использование внешних ресурсов.
//
// Возвращаемое значение: Структура, см. ТаблицыРазрешений().
//
Функция ТекущийСрезРазрешений()
	
	Результат = ТаблицыРазрешений();
	
	Менеджеры = МенеджерыРегистровРазрешений();
	Для Каждого Менеджер Из Менеджеры Цикл
		
		ЗапросТекущегоСреза = Новый Запрос(Менеджер.ЗапросТекущегоСреза(Ложь));
		Результат[Менеджер.ТипXDTOПредставленияРазрешений().Имя] = ЗапросТекущегоСреза.Выполнить().Выгрузить();
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Применение запросов разрешений
//

// Рассчитывает изменения в разрешениях на использование внешних ресурсов, которые должны
// быть внесены в настройки профилей безопасности при обработке запросов на использование
// внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на
//    использование внешних ресурсов, для которых требуется получить изменения, которые должны
//    быть внесены в настройки профилей безопасности при применении разрешений.
//
// Возвращаемое значение: ТаблицаЗначений:
//                          * ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника, соответствуюшая
//                              внешнему модулю, для которого выполняется запрос разрешений на использование
//                              внешних ресурсов,
//                          * Изменения - Структура:
//                              * Добавляемые - Структура, содержащая таблицы с описаниями разрешений, которые
//                                  должны быть добавлены в настройки профилей безопасности в кластере серверов
//                                  при применении запросов (см. ТаблицыРазрешений()),
//                              * Удаляемые - Структура, содержащая таблицы с описаниями разрешений, которые
//                                  должны быть удалены из настроек профилей безопасности в кластере серверов
//                                  при применении запросов (см. ТаблицыРазрешений()),
//                          * Приоритет - Число, приоритет текущего внешнего модуля (для случаев визуального
//                              отображения рассчитанной дельты в пользовательском интерфейсе).
//
Функция ДельтаИзмененийРазрешенийНаИспользованиеВнешнихРесурсов(Знач ИдентификаторыЗапросов) Экспорт
	
	МенеджерыРегистров = МенеджерыРегистровРазрешений();
	СоответствиеРасчетаДельты = Новый Соответствие();
	
	НачатьТранзакцию();
	
	Попытка
		
		ЗаблокироватьРегистрыПредоставленныхРазрешений();
		
		ИменаПервыхВТ = "ВТ_До";
		ИменаВторыхВТ = "ВТ_После";
		ПсевдонимыПомещаемыхТаблиц = "Таблица";
		
		ТекущийСрез = ТекущийСрезРазрешений();
		Для Каждого МенеджерРегистра Из МенеджерыРегистров Цикл
			
			ИмяТаблицы = МенеджерРегистра.ТипXDTOПредставленияРазрешений().Имя;
			ТекущийСрезПоТаблице = ТекущийСрез[ИмяТаблицы];
			
			МенеджерВТ = Новый МенеджерВременныхТаблиц();
			
			ЗапросСозданияВТ = Новый Запрос(ТекстЗапросаСозданияВТ(ТекущийСрезПоТаблице, ПсевдонимыПомещаемыхТаблиц, ИменаПервыхВТ));
			ЗапросСозданияВТ.УстановитьПараметр(ПсевдонимыПомещаемыхТаблиц, ТекущийСрезПоТаблице);
			ЗапросСозданияВТ.МенеджерВременныхТаблиц = МенеджерВТ;
			ЗапросСозданияВТ.Выполнить();
			
			СоответствиеРасчетаДельты.Вставить(МенеджерРегистра, МенеджерВТ);
			
		КонецЦикла;
		
		ПрименитьЗапросыКТаблицамРазрешений(ИдентификаторыЗапросов, ТекущийСрез);
		
		Добавляемые = ТаблицыРазрешений();
		Удаляемые = ТаблицыРазрешений();
		
		Для Каждого ЭлементСоответствияРасчетаДельты Из СоответствиеРасчетаДельты Цикл
			
			МенеджерРегистра = ЭлементСоответствияРасчетаДельты.Ключ;
			ИмяТаблицы = МенеджерРегистра.ТипXDTOПредставленияРазрешений().Имя;
			МенеджерВТ = ЭлементСоответствияРасчетаДельты.Значение;
			
			ТекущийСрезПоТаблице = ТекущийСрез[ИмяТаблицы];
			
			ЗапросСозданияВТ = Новый Запрос(ТекстЗапросаСозданияВТ(ТекущийСрезПоТаблице, ПсевдонимыПомещаемыхТаблиц, ИменаВторыхВТ));
			ЗапросСозданияВТ.УстановитьПараметр(ПсевдонимыПомещаемыхТаблиц, ТекущийСрезПоТаблице);
			ЗапросСозданияВТ.МенеджерВременныхТаблиц = МенеджерВТ;
			ЗапросСозданияВТ.Выполнить();
			
			Запрос = Новый Запрос(МенеджерРегистра.ЗапросПолученияДельты());
			Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
			
			Результаты = Запрос.ВыполнитьПакет();
			
			Порция = Удаляемые[ИмяТаблицы];
			Если Порция = Неопределено Тогда
				Удаляемые.Вставить(ИмяТаблицы, Результаты[0].Выгрузить());
			Иначе
				ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Результаты[0].Выгрузить(), Порция);
				Удаляемые.Вставить(ИмяТаблицы, Порция);
			КонецЕсли;
			
			Порция = Добавляемые[ИмяТаблицы];
			Если Порция = Неопределено Тогда
				Добавляемые.Вставить(ИмяТаблицы, Результаты[1].Выгрузить());
			Иначе
				ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Результаты[1].Выгрузить(), Порция);
				Добавляемые.Вставить(ИмяТаблицы, Порция);
			КонецЕсли;
			
		КонецЦикла;
		
		Результат = Новый ТаблицаЗначений();
		Результат.Колонки.Добавить("ВнешнийМодуль");
		Результат.Колонки.Добавить("Изменения", Новый ОписаниеТипов("Структура"));
		
		Для Каждого КлючИЗначение Из Добавляемые Цикл
			
			ИмяТаблицы = КлючИЗначение.Ключ;
			Таблица = КлючИЗначение.Значение;
			
			Для Каждого Строка Из Таблица Цикл
				
				ВнешнийМодуль = СсылкаИзРегистраРазрешений(
					Строка.ТипПрограммногоМодуля, Строка.ИдентификаторПрограммногоМодуля);
				
				ОтборПоМодулю = Новый Структура("ВнешнийМодуль", ВнешнийМодуль);
				СтрокиПоМодулю = Результат.НайтиСтроки(ОтборПоМодулю);
				Если СтрокиПоМодулю.Количество() = 0 Тогда
					СтрокаПоМодулю = Результат.Добавить();
					СтрокаПоМодулю.ВнешнийМодуль = ВнешнийМодуль;
					РезультатПоМодулю = Новый Структура("Добавляемые, Удаляемые", ТаблицыРазрешений(), ТаблицыРазрешений());
				ИначеЕсли СтрокиПоМодулю.Количество() = 1 Тогда
					СтрокаПоМодулю = СтрокиПоМодулю.Получить(0);
					РезультатПоМодулю = СтрокаПоМодулю.Изменения;
				Иначе
					ВызватьИсключение НСтр("ru = 'Неоднозначность при определении изменений в разрешениях'");
				КонецЕсли;
				
				ТаблицаРезультата = РезультатПоМодулю.Добавляемые[ИмяТаблицы];
				СтрокаТаблицыРезультата = ТаблицаРезультата.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыРезультата, Строка);
				
				РезультатПоМодулю.Добавляемые.Вставить(ИмяТаблицы, ТаблицаРезультата);
				
				СтрокаПоМодулю.Изменения = РезультатПоМодулю;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Для Каждого КлючИЗначение Из Удаляемые Цикл
			
			ИмяТаблицы = КлючИЗначение.Ключ;
			Таблица = КлючИЗначение.Значение;
			
			Для Каждого Строка Из Таблица Цикл
				
				ВнешнийМодуль = СсылкаИзРегистраРазрешений(
					Строка.ТипПрограммногоМодуля, Строка.ИдентификаторПрограммногоМодуля);
				
				ОтборПоМодулю = Новый Структура("ВнешнийМодуль", ВнешнийМодуль);
				СтрокиПоМодулю = Результат.НайтиСтроки(ОтборПоМодулю);
				Если СтрокиПоМодулю.Количество() = 0 Тогда
					СтрокаПоМодулю = Результат.Добавить();
					СтрокаПоМодулю.ВнешнийМодуль = ВнешнийМодуль;
					РезультатПоМодулю = Новый Структура("Добавляемые, Удаляемые", ТаблицыРазрешений(), ТаблицыРазрешений());
				ИначеЕсли СтрокиПоМодулю.Количество() = 1 Тогда
					СтрокаПоМодулю = СтрокиПоМодулю.Получить(0);
					РезультатПоМодулю = СтрокаПоМодулю.Изменения;
				Иначе
					ВызватьИсключение НСтр("ru = 'Неоднозначность при определении изменений в разрешениях'");
				КонецЕсли;
				
				ТаблицаРезультата = РезультатПоМодулю.Удаляемые[ИмяТаблицы];
				СтрокаТаблицыРезультата = ТаблицаРезультата.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыРезультата, Строка);
				
				РезультатПоМодулю.Удаляемые.Вставить(ИмяТаблицы, ТаблицаРезультата);
				
				СтрокаПоМодулю.Изменения = РезультатПоМодулю;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Результат.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
		Для Каждого СтрокаРезультата Из Результат Цикл
			Если СтрокаРезультата.ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
				СтрокаРезультата.Приоритет = 1;
			Иначе
				СтрокаРезультата.Приоритет = 2;
			КонецЕсли;
		КонецЦикла;
		Результат.Сортировать("Приоритет");
		
		ЗафиксироватьТранзакцию();
		
		Возврат Результат;
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецФункции

// Формирует текст запроса создания временной таблицы при расчеты дельты.
//
// Параметры:
//  ТекущаяТаблица - ТаблицаЗначений - см. ТаблицаРазрешений(),
//  ПсевдонимТаблицы - Строка - псевдоним для таблицы (для текста запроса),
//  ИмяВТ - Строка - имя временной таблицы (для текста запроса).
//
// Возвращаемое значение: Строка - текст запроса.
//
Функция ТекстЗапросаСозданияВТ(Знач ТекущаяТаблица, Знач ПсевдонимТаблицы, Знач ИмяВТ)
	
	ПоляВыборки = Новый Массив();
	
	Для Каждого Колонка Из ТекущаяТаблица.Колонки Цикл
		ПоляВыборки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	ТекстВыборки = "";
	Для Каждого ПолеВыборки Из ПоляВыборки Цикл
		
		Если Не ПустаяСтрока(ТекстВыборки) Тогда
			ТекстВыборки = ТекстВыборки + ", ";
		КонецЕсли;
		
		ТекстВыборки = ТекстВыборки + ПсевдонимТаблицы + "." + ПолеВыборки + " КАК " + ПолеВыборки;
		
	КонецЦикла;
	
	ТекстЗапроса = "Выбрать %1 Поместить %2 Из &%3 КАК %3";
	ТекстЗапроса = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ТекстЗапроса, ТекстВыборки, ИмяВТ, ПсевдонимТаблицы);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Строит план применения запросов на использование внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на
//    использование внешних ресурсов, для которых требуется получить изменения, которые должны
//    быть внесены в настройки профилей безопасности при применении разрешений.
//
// Возвращаемое значение: Структура:
//                          * ЗамещаемыеПоТипам - ТаблицаЗначений - план выполнения замещения
//                                предыдущих значений для ранее предоставленных разрешений:
//                              * ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника,
//                                 испольуемая в качестве внешнего модуля,
//                              * Владелец - ЛюбаяСсылка - ссылка на элемент справочника, используемый
//                                 в качестве владельца разрешений,
//                              * Тип - Строка - имя XDTO-типа, описывающего типа разрешений. Тип должен быть
//                                 определен в пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d}.
//                          * ДобавляемыеПоТипам - ТаблицаЗначений - план добавления разрешений на использование
//                                внешних ресурсов:
//                              * ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника,
//                                 испольуемая в качестве внешнего модуля,
//                              * Владелец - ЛюбаяСсылка - ссылка на элемент справочника, используемый
//                                 в качестве владельца разрешений,
//                              * Тип - Строка - имя XDTO-типа, описывающего типа разрешений. Тип должен быть
//                                 определен в пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d},
//                              * Разрешения - Массив(ОбъектXDTO) - массив объектов XDTO, описывающих разрешения
//                                 на использование внешних ресурсов. Типы объектов должны быть определены в
//                                 пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d},
//                          * УдаляемыеПоТипам - ТаблицаЗначений - план удаления разрешений на использование
//                                 внешних ресурсов:
//                              * ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника,
//                                 испольуемая в качестве внешнего модуля,
//                              * Владелец - ЛюбаяСсылка - ссылка на элемент справочника, используемый
//                                 в качестве владельца разрешений,
//                              * Тип - Строка - имя XDTO-типа, описывающего типа разрешений. Тип должен быть
//                                 определен в пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d},
//                              * Разрешения - Массив(ОбъектXDTO) - массив объектов XDTO, описывающих разрешения
//                                 на использование внешних ресурсов. Типы объектов должны быть определены в
//                                 пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d}.
//
Функция ПланПримененияЗапросовНаИспользованиеВнешнихРесурсов(Знач ИдентификаторыЗапросов)
	
	Менеджеры = МенеджерыРегистровРазрешений();
	
	ЗамещаемыеПоТипам = Новый ТаблицаЗначений();
	ЗамещаемыеПоТипам.Колонки.Добавить("ВнешнийМодуль");
	ЗамещаемыеПоТипам.Колонки.Добавить("Владелец");
	ЗамещаемыеПоТипам.Колонки.Добавить("Тип", Новый ОписаниеТипов("Строка"));
	
	ДобавляемыеПоТипам = Новый ТаблицаЗначений();
	ДобавляемыеПоТипам.Колонки.Добавить("ВнешнийМодуль");
	ДобавляемыеПоТипам.Колонки.Добавить("Владелец");
	ДобавляемыеПоТипам.Колонки.Добавить("Тип", Новый ОписаниеТипов("Строка"));
	ДобавляемыеПоТипам.Колонки.Добавить("Разрешения", Новый ОписаниеТипов("Массив"));
	
	УдаляемыеПоТипам = Новый ТаблицаЗначений();
	УдаляемыеПоТипам.Колонки.Добавить("ВнешнийМодуль");
	УдаляемыеПоТипам.Колонки.Добавить("Владелец",);
	УдаляемыеПоТипам.Колонки.Добавить("Тип", Новый ОписаниеТипов("Строка"));
	УдаляемыеПоТипам.Колонки.Добавить("Разрешения", Новый ОписаниеТипов("Массив")); 
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	Запросы.ИдентификаторЗапроса,
		|	Запросы.ТипПрограммногоМодуля,
		|	Запросы.ИдентификаторПрограммногоМодуля,
		|	Запросы.ТипВладельца,
		|	Запросы.ИдентификаторВладельца,
		|	Запросы.РежимЗамещения,
		|	Запросы.ДобавляемыеРазрешения,
		|	Запросы.УдаляемыеРазрешения,
		|	Запросы.МоментВремени
		|ИЗ
		|	РегистрСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов КАК Запросы
		|ГДЕ
		|	Запросы.ИдентификаторЗапроса В(&Идентификаторы)";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Идентификаторы", ИдентификаторыЗапросов);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.РежимЗамещения Тогда
			
			// Замещение по всем таблицам
			
			Для Каждого Менеджер Из Менеджеры Цикл
				
				ТипТаблицы = Менеджер.ТипXDTOПредставленияРазрешений().Имя;
				
				СтрокаЗамещения = ЗамещаемыеПоТипам.Добавить();
				СтрокаЗамещения.ВнешнийМодуль = СсылкаИзРегистраРазрешений(
					Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля);
				СтрокаЗамещения.Владелец = СсылкаИзРегистраРазрешений(
					Выборка.ТипВладельца, Выборка.ИдентификаторВладельца);
				СтрокаЗамещения.Тип = ТипТаблицы;
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если Не ПустаяСтрока(Выборка.ДобавляемыеРазрешения) Тогда
			
			МассивДобавляемыхРазрешений = ОбщегоНазначения.ЗначениеИзСтрокиXML(Выборка.ДобавляемыеРазрешения);
			Для Каждого ПредставлениеРазрешения Из МассивДобавляемыхРазрешений Цикл
				
				Разрешение = ОбщегоНазначения.ОбъектXDTOИзСтрокиXML(ПредставлениеРазрешения);
				
				ПрограммныйМодуль = СсылкаИзРегистраРазрешений(
					Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля);
				Владелец = СсылкаИзРегистраРазрешений(Выборка.ТипВладельца, Выборка.ИдентификаторВладельца);
				
				ТипРазрешения = Разрешение.Тип().Имя;
				Отбор = Новый Структура("ВнешнийМодуль,Владелец,Тип", ПрограммныйМодуль, Владелец, ТипРазрешения);
				Строки = ДобавляемыеПоТипам.НайтиСтроки(Отбор);
				Если Строки.Количество() = 0 Тогда
					Строка = ДобавляемыеПоТипам.Добавить();
					Строка.ВнешнийМодуль = ПрограммныйМодуль;
					Строка.Владелец = Владелец;
					Строка.Тип = ТипРазрешения;
				Иначе
					Строка = Строки.Получить(0);
				КонецЕсли;
				
				Строка.Разрешения.Добавить(Разрешение);
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если Не ПустаяСтрока(Выборка.УдаляемыеРазрешения) Тогда
			
			МассивУдаляемыхРазрешений = ОбщегоНазначения.ЗначениеИзСтрокиXML(Выборка.УдаляемыеРазрешения);
			Для Каждого ПредставлениеРазрешения Из МассивУдаляемыхРазрешений Цикл
				
				Разрешение = ОбщегоНазначения.ОбъектXDTOИзСтрокиXML(ПредставлениеРазрешения);
				
				ПрограммныйМодуль = СсылкаИзРегистраРазрешений(
					Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля);
				Владелец = СсылкаИзРегистраРазрешений(Выборка.ТипВладельца, Выборка.ИдентификаторВладельца);
				
				ТипРазрешения = Разрешение.Тип().Имя;
				Отбор = Новый Структура("ВнешнийМодуль,Владелец,Тип", ПрограммныйМодуль, Владелец, ТипРазрешения);
				Строки = УдаляемыеПоТипам.НайтиСтроки(Отбор);
				Если Строки.Количество() = 0 Тогда
					Строка = ДобавляемыеПоТипам.Добавить();
					Строка.ВнешнийМодуль = ПрограммныйМодуль;
					Строка.Владелец = Владелец;
					Строка.Тип = ТипРазрешения;
				Иначе
					Строка = Строки.Получить(0);
				КонецЕсли;
				
				Строка.Разрешения.Добавить(Разрешение);
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Результат = Новый Структура();
	Результат.Вставить("ЗамещаемыеПоТипам", ЗамещаемыеПоТипам);
	Результат.Вставить("ДобавляемыеПоТипам", ДобавляемыеПоТипам);
	Результат.Вставить("УдаляемыеПоТипам" ,УдаляемыеПоТипам);
	
	Возврат Результат;
	
КонецФункции

// Применяет запросы на использование внешних ресурсов к таблицам разрешений.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на
//    использование внешних ресурсов, для которых требуется получить изменения, которые должны
//    быть внесены в настройки профилей безопасности при применении разрешений,
//  ТаблицыРазрешений - Структура - описывающая разрешения на использование внешних ресурсов
//    (см. ТаблицыРазрешений()).
//
Процедура ПрименитьЗапросыКТаблицамРазрешений(Знач ИдентификаторыЗапросов, ТаблицыРазрешений)
	
	Менеджеры = МенеджерыРегистровРазрешений();
	
	План = ПланПримененияЗапросовНаИспользованиеВнешнихРесурсов(ИдентификаторыЗапросов);
	
	Для Каждого ЗамещаемыеПоТипу Из План.ЗамещаемыеПоТипам Цикл
		
		ИмяТипа = ЗамещаемыеПоТипу.Тип;
		Таблица = ТаблицыРазрешений[ИмяТипа];
		
		ПараметрыОтбора = Новый Структура();
		
		СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ЗамещаемыеПоТипу.ВнешнийМодуль);
		ПараметрыОтбора.Вставить("ТипПрограммногоМодуля", СвойстваПрограммногоМодуля.Тип);
		ПараметрыОтбора.Вставить("ИдентификаторПрограммногоМодуля", СвойстваПрограммногоМодуля.Идентификатор);
		
		СвойстваВладельца = СвойстваДляРегистраРазрешений(ЗамещаемыеПоТипу.Владелец);
		ПараметрыОтбора.Вставить("ТипВладельца", СвойстваВладельца.Тип);
		ПараметрыОтбора.Вставить("ИдентификаторВладельца", СвойстваВладельца.Идентификатор);
		
		Строки = Таблица.НайтиСтроки(ПараметрыОтбора);
		Для Каждого Строка Из Строки Цикл
			Таблица.Удалить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого ДобавляемыеПоТипу Из План.ДобавляемыеПоТипам Цикл
		
		ИмяТипа = ДобавляемыеПоТипу.Тип;
		Таблица = ТаблицыРазрешений[ИмяТипа];
		
		ТекущийМенеджер = Неопределено;
		Для Каждого Менеджер Из Менеджеры Цикл
			Если Менеджер.ТипXDTOПредставленияРазрешений().Имя = ИмяТипа Тогда
				ТекущийМенеджер = Менеджер;
			КонецЕсли;
		КонецЦикла;
		Если ТекущийМенеджер = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при разборе запроса разрешений на использование внешних ресурсов: неизвестное имя типа %1!'"),
				ИмяТипа);
		КонецЕсли;
		
		НаборЗаписей = ТекущийМенеджер.НаборЗаписейИзXDTOПредставления(ДобавляемыеПоТипу.Разрешения, ДобавляемыеПоТипу.ВнешнийМодуль, ДобавляемыеПоТипу.Владелец, Ложь);
		
		Для Каждого Запись Из НаборЗаписей Цикл
			Строка = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(Строка, Запись);
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого УдаляемыеПоТипу Из План.УдаляемыеПоТипам Цикл
		
		ИмяТипа = УдаляемыеПоТипу.Тип;
		Таблица = ТаблицыРазрешений[ИмяТипа];
		
		ТекущийМенеджер = Неопределено;
		Для Каждого Менеджер Из Менеджеры Цикл
			Если Менеджер.ТипXDTOПредставленияРазрешений().Имя = ИмяТипа Тогда
				ТекущийМенеджер = Менеджер;
			КонецЕсли;
		КонецЦикла;
		Если ТекущийМенеджер = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при разборе запроса разрешений на использование внешних ресурсов: неизвестное имя типа %1!'"),
				ИмяТипа);
		КонецЕсли;
		
		НаборЗаписей = ТекущийМенеджер.НаборЗаписейИзXDTOПредставления(УдаляемыеПоТипу.Разрешения, УдаляемыеПоТипу.ВнешнийМодуль, УдаляемыеПоТипу.Владелец, Истина);
		
		ПараметрыОтбора = Новый Структура();
		Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
			Если ЭлементОтбора.Использование Тогда
				Если Таблица.Колонки.Найти(ЭлементОтбора.ПутьКДанным) <> Неопределено Тогда
					Если ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
						ПараметрыОтбора.Вставить(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
					Иначе
						ВызватьИсключение НСтр("ru = 'Некорректный вид сравнения!'");
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Строки = Таблица.НайтиСтроки(ПараметрыОтбора);
		Для Каждого Строка Из Строки Цикл
			Таблица.Удалить(Строка);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Применяет запросы на использование внешних ресурсов к регистрам разрешений.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на
//    использование внешних ресурсов, для которых требуется получить изменения, которые должны
//    быть внесены в настройки профилей безопасности при применении разрешений.
//
Процедура ПрименитьЗапросыКРегистрамРазрешений(Знач ИдентификаторыЗапросов)
	
	НачатьТранзакцию();
	
	Попытка
		
		Менеджеры = МенеджерыРегистровРазрешений();
		
		План = ПланПримененияЗапросовНаИспользованиеВнешнихРесурсов(ИдентификаторыЗапросов);
		
		Для Каждого ЗамещаемыеПоТипу Из План.ЗамещаемыеПоТипам Цикл
			
			ИмяТипа = ЗамещаемыеПоТипу.Тип;
			ТекущийМенеджер = Неопределено;
			Для Каждого Менеджер Из Менеджеры Цикл
				Если Менеджер.ТипXDTOПредставленияРазрешений().Имя = ИмяТипа Тогда
					ТекущийМенеджер = Менеджер;
				КонецЕсли;
			КонецЦикла;
			Если ТекущийМенеджер = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при разборе запроса разрешений на использование внешних ресурсов: неизвестное имя типа %1!'"),
					ИмяТипа);
			КонецЕсли;
			
			Модуль = ЗамещаемыеПоТипу.ВнешнийМодуль;
			Владелец = ЗамещаемыеПоТипу.Владелец;
			
			НаборЗаписей = ТекущийМенеджер.НаборЗаписейИзXDTOПредставления(Неопределено, Модуль, Владелец, Истина);
			НаборЗаписей.Записать(Истина);
			
		КонецЦикла;
		
		Для Каждого ДобавляемыеПоТипу Из План.ДобавляемыеПоТипам Цикл
			
			ИмяТипа = ДобавляемыеПоТипу.Тип;
			ТекущийМенеджер = Неопределено;
			Для Каждого Менеджер Из Менеджеры Цикл
				Если Менеджер.ТипXDTOПредставленияРазрешений().Имя = ИмяТипа Тогда
					ТекущийМенеджер = Менеджер;
				КонецЕсли;
			КонецЦикла;
			Если ТекущийМенеджер = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при разборе запроса разрешений на использование внешних ресурсов: неизвестное имя типа %1!'"),
					ИмяТипа);
			КонецЕсли;
			
			Модуль = ДобавляемыеПоТипу.ВнешнийМодуль;
			Владелец = ДобавляемыеПоТипу.Владелец;
			
			НаборЗаписей = ТекущийМенеджер.НаборЗаписейИзXDTOПредставления(ДобавляемыеПоТипу.Разрешения, Модуль, Владелец, Ложь);
			НаборЗаписей.Записать(Ложь);
			
		КонецЦикла;
		
		Для Каждого УдаляемыеПоТипу Из План.УдаляемыеПоТипам Цикл
			
			ИмяТипа = УдаляемыеПоТипу.Тип;
			ТекущийМенеджер = Неопределено;
			Для Каждого Менеджер Из Менеджеры Цикл
				Если Менеджер.ТипXDTOПредставленияРазрешений().Имя = ИмяТипа Тогда
					ТекущийМенеджер = Менеджер;
				КонецЕсли;
			КонецЦикла;
			Если ТекущийМенеджер = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при разборе запроса разрешений на использование внешних ресурсов: неизвестное имя типа %1!'"),
					ИмяТипа);
			КонецЕсли;
			
			Модуль = УдаляемыеПоТипу.ВнешнийМодуль;
			Владелец = УдаляемыеПоТипу.Владелец;
			
			НаборЗаписей = ТекущийМенеджер.НаборЗаписейИзXDTOПредставления(УдаляемыеПоТипу.Разрешения, Модуль, Владелец, Истина);
			НаборЗаписей.Записать(Истина);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Применяет запросы на использование внешних ресурсов (должна вызываться после изменения настроек
// профилей безопасности в кластере серверов).
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы применяемых запросов.
//
Процедура ПрименитьЗапросы(Знач ИдентификаторыЗапросов) Экспорт
	
	Если МонопольныйРежим() Тогда
		
		ОчисткаНеактуальныхЗапросовНаИспользованиеВнешнихРесурсов();
		
	Иначе
		
		Попытка
			
			ПараметрыЗадания = Новый Массив();
			ПараметрыЗадания.Добавить("Обработки.НастройкаРазрешенийНаИспользованиеВнешнихРесурсов.ОчисткаНеактуальныхЗапросовНаИспользованиеВнешнихРесурсов");
			
			ФоновыеЗадания.Выполнить("РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации", ПараметрыЗадания,"f023cc5d-1846-4c49-b0ba-27aa65924879");
			
		Исключение
			// Обработка исключения не требуется.
			// Ожидаемое исключение - дублирование заданий с одинаковым ключем.
		КонецПопытки;
		
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		
		ЗаблокироватьРегистрыПредоставленныхРазрешений();
		ПрименитьЗапросыКРегистрамРазрешений(ИдентификаторыЗапросов);
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Выполняет дополнительные действия после применения запросов на использование внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы применяемых запросов.
//
Процедура ПослеОбработкиЗапросов(Знач ИдентификаторыЗапросов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		ТекстЗапроса =
			"ВЫБРАТЬ
			|	Запросы.ИдентификаторЗапроса КАК ИдентификаторЗапроса,
			|	Запросы.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
			|	Запросы.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля,
			|	Запросы.Операция,
			|	Запросы.Имя
			|ИЗ
			|	РегистрСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов КАК Запросы
			|ГДЕ
			|	Запросы.ИдентификаторЗапроса В(&Идентификаторы)";
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Идентификаторы", ИдентификаторыЗапросов);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			ПрограммныйМодуль = СсылкаИзРегистраРазрешений(
				Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля);
			
			ЭтоПрофильКонфигурации = (ПрограммныйМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
			
			Если Выборка.Операция = Перечисления.ОперацииСНаборамиРазрешений.Создание Тогда
				
				Если ЭтоПрофильКонфигурации Тогда
					
					Константы.ПрофильБезопасностиИнформационнойБазы.Установить(Выборка.Имя);
					
				Иначе
					
					Набор = РегистрыСведений.РежимыПодключенияВнешнихМодулей.СоздатьНаборЗаписей();
					Набор.Отбор.ТипПрограммногоМодуля.Установить(Выборка.ТипПрограммногоМодуля);
					Набор.Отбор.ИдентификаторПрограммногоМодуля.Установить(Выборка.ИдентификаторПрограммногоМодуля);
					Запись = Набор.Добавить();
					Запись.ТипПрограммногоМодуля = Выборка.ТипПрограммногоМодуля;
					Запись.ИдентификаторПрограммногоМодуля = Выборка.ИдентификаторПрограммногоМодуля;
					Запись.БезопасныйРежим = Выборка.Имя;
					Набор.Записать();
					
				КонецЕсли;
				
			Иначе
				
				Если ЭтоПрофильКонфигурации Тогда
					
					Константы.ПрофильБезопасностиИнформационнойБазы.Установить("");
					ОчиститьПредоставленныеРазрешения();
					
				Иначе
					
					ОчиститьПредоставленныеРазрешения(ПрограммныйМодуль, Истина);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Формирует результат применения запросов на использование внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы применяемых запросов.
//
// Возвращаемое значение: Соответствие:
//                         * Ключ - ЛюбаяСсылка - ссылка на элемент справочника, соответствующий
//                             внешнему модулю,
//                         * Значение - Структура - таблицы разрешений в том виде, который они должны
//                             принять после применения запросов на использование внешних ресурсов (см.
//                             ТаблицыРазрешений()).
//
Функция РезультатПримененияЗапросовНаИспользованиеВнешнихРесурсов(Знач ИдентификаторыЗапросов)
	
	НачатьТранзакцию();
	
	Попытка
		
		ЗаблокироватьРегистрыПредоставленныхРазрешений();
		
		ТекущийСрез = ТекущийСрезРазрешений();
		ПрименитьЗапросыКТаблицамРазрешений(ИдентификаторыЗапросов, ТекущийСрез);
		
		Для Каждого ЭлементСреза Из ТекущийСрез Цикл
			
			КолонкиГруппировок = Новый Массив();
			Для Каждого Колонка Из ЭлементСреза.Значение.Колонки Цикл
				КолонкиГруппировок.Добавить(Колонка.Имя);
			КонецЦикла;
			Индекс = КолонкиГруппировок.Найти("Владелец");
			Если Индекс <> Неопределено Тогда
				КолонкиГруппировок.Удалить(Индекс);
			КонецЕсли;
			
			ЭлементСреза.Значение.Свернуть(СтроковыеФункцииКлиентСервер.ПолучитьСтрокуИзМассиваПодстрок(КолонкиГруппировок, ", "));
			
		КонецЦикла;
		
		Результат = Новый Соответствие();
		
		Для Каждого КлючИЗначение Из ТекущийСрез Цикл
			
			ИмяТаблицы = КлючИЗначение.Ключ;
			Таблица = КлючИЗначение.Значение;
			
			Для Каждого Строка Из Таблица Цикл
				
				ВнешнийМодуль = СсылкаИзРегистраРазрешений(Строка.ТипПрограммногоМодуля, Строка.ИдентификаторПрограммногоМодуля);
				
				РезультатПоМодулю = Результат.Получить(ВнешнийМодуль);
				Если РезультатПоМодулю = Неопределено Тогда
					РезультатПоМодулю = ТаблицыРазрешений();
				КонецЕсли;
				
				ТаблицаРезультата = РезультатПоМодулю[ИмяТаблицы];
				СтрокаТаблицыРезультата = ТаблицаРезультата.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыРезультата, Строка);
				
				РезультатПоМодулю.Вставить(ИмяТаблицы, ТаблицаРезультата);
				Результат.Вставить(ВнешнийМодуль, РезультатПоМодулю);
				
			КонецЦикла;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
		Возврат Результат;
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецФункции

// Формирует сценарий примнения запросов на использование внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на использование
//    внешних ресурсов, для примнения которых формируется сценарий.
//
// Возвращаемое значение - Массив(Структура) - сценарий применения запросов на использование внешних
// ресурсов. Значениями массива являются структуры со следующими полями:
//   * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую требуется выполнить,
//   * Профиль - Строка, имя профиля безопасности,
//   * Разрешения - Структура - описание свойств профиля безопасности, см. АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Функция СценарийПримененияЗапросовНаИзменениеДоступаКВнешнимРесурсам(Знач ИдентификаторыЗапросов)
	
	Результат = Новый Массив();
	
	ИменаПрофилей = Новый Соответствие();
	
	ОперацииАдминистрирования = ОперацииАдминистрированияВЗапросах(ИдентификаторыЗапросов);
	
	Для Каждого Описание Из ОперацииАдминистрирования Цикл
		
		ЭтоПрофильКонфигурации = (Описание.ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		ИмяПрофиля = Описание.Имя;
		
		ИменаПрофилей.Вставить(Описание.ВнешнийМодуль, ИмяПрофиля);
		
		ЭлементРезультата = Новый Структура("Операция,Профиль,Разрешения");
		ЭлементРезультата.Операция = Описание.Операция;
		ЭлементРезультата.Профиль = ИмяПрофиля;
		
		ДополнительныйЭлементРезультата = Неопределено;
		ПриоритетДополнительногоЭлемента = Ложь;
		
		Если ЭтоПрофильКонфигурации И Описание.Операция = Перечисления.ОперацииСНаборамиРазрешений.Создание Тогда
			
			ДополнительныйЭлементРезультата = Новый Структура("Операция,Профиль,Разрешения");
			ДополнительныйЭлементРезультата.Операция = Перечисления.ОперацииСНаборамиРазрешений.Назначение;
			ДополнительныйЭлементРезультата.Профиль = ИмяПрофиля;
			
			ПриоритетДополнительногоЭлемента = Ложь;
			
		КонецЕсли;
		
		Если ЭтоПрофильКонфигурации И Описание.Операция = Перечисления.ОперацииСНаборамиРазрешений.Удаление Тогда
			
			ДополнительныйЭлементРезультата = Новый Структура("Операция,Профиль,Разрешения");
			ДополнительныйЭлементРезультата.Операция = Перечисления.ОперацииСНаборамиРазрешений.УдалениеНазначения;
			ДополнительныйЭлементРезультата.Профиль = ИмяПрофиля;
			
			ПриоритетДополнительногоЭлемента = Истина;
			
		КонецЕсли;
		
		Если ДополнительныйЭлементРезультата = Неопределено Тогда
			
			Результат.Добавить(ЭлементРезультата);
			
		Иначе
			
			Если ПриоритетДополнительногоЭлемента Тогда
				
				Результат.Добавить(ДополнительныйЭлементРезультата);
				Результат.Добавить(ЭлементРезультата);
				
			Иначе
				
				Результат.Добавить(ЭлементРезультата);
				Результат.Добавить(ДополнительныйЭлементРезультата);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Дельта = ДельтаИзмененийРазрешенийНаИспользованиеВнешнихРесурсов(ИдентификаторыЗапросов);
	РезультатПримененияЗапросов = РезультатПримененияЗапросовНаИспользованиеВнешнихРесурсов(ИдентификаторыЗапросов);
	
	Для Каждого ФрагментИзменений Из Дельта Цикл
		
		Модуль = ФрагментИзменений.ВнешнийМодуль;
		
		ИмяПрофиля = ИменаПрофилей.Получить(Модуль);
		Если ИмяПрофиля = Неопределено Тогда
			
			Если Модуль <> Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
				ИмяПрофиля = РежимПодключенияВнешнегоМодуля(Модуль);
			Иначе
				ИмяПрофиля = Константы.ПрофильБезопасностиИнформационнойБазы.Получить();
			КонецЕсли;
			
		КонецЕсли;
		
		ОписаниеПрофиля = НовоеОписаниеПрофиляБезопасности(Модуль);
		
		Добавлять = Истина;
		ЭлементРезультата = Неопределено;
		Для Каждого Этап Из Результат Цикл
			Если Этап.Операция = Перечисления.ОперацииСНаборамиРазрешений.Создание И Этап.Профиль = ИмяПрофиля Тогда
				ЭлементРезультата = Этап;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЭлементРезультата = Неопределено Тогда
			
			ЭлементРезультата = Новый Структура("Операция,Профиль,Разрешения");
			
			ЭлементРезультата.Операция = Перечисления.ОперацииСНаборамиРазрешений.Обновление;
			ЭлементРезультата.Профиль = ИмяПрофиля;
			
		Иначе
			Добавлять = Ложь;
		КонецЕсли;
		
		Если Модуль <> Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() И ЭлементРезультата.Операция = Перечисления.ОперацииСНаборамиРазрешений.Обновление Тогда
			
			Если Не ПрофильБезопасностиНазначенВнешнемуМодулю(ЭлементРезультата.Профиль) Тогда
				ЭлементРезультата.Операция = Перечисления.ОперацииСНаборамиРазрешений.Создание;
			КонецЕсли;
			
		КонецЕсли;
		
		ЭлементРезультата.Разрешения = ПрофильВНотацииИнтерфейсаАдминистрированияКластера(ЭлементРезультата.Профиль, ОписаниеПрофиля, РезультатПримененияЗапросов.Получить(Модуль));
		
		Если Добавлять Тогда
			Результат.Добавить(ЭлементРезультата);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует описание профиля безопасности в нотации программного интерфейса администрирования
// кластера серверов.
//
// Параметры:
//  ИмяПрофиля - Строка - имя профиля безопасности,
//  ОписаниеПрофиля - Строка - описание профиля безопасности,
//  Разрешения - Массив(ОбъектXDTO) - массив объектов XDTO, описывающих разрешения
//    на использование внешних ресурсов. Типы объектов должны быть определены в
//    пакете {http://www.1c.ru/1cFresh/Application/Permissions/a.b.c.d}.
//
// Возвращаемое значение: Структура - см. АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Функция ПрофильВНотацииИнтерфейсаАдминистрированияКластера(Знач ИмяПрофиля, Знач ОписаниеПрофиля, Знач Разрешения)
	
	Профиль = АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности();
	Профиль.Имя = ИмяПрофиля;
	Профиль.Описание = ОписаниеПрофиля;
	Профиль.ПрофильБезопасногоРежима = Истина;
	
	Профиль.ПолныйДоступКФайловойСистеме = Ложь;
	Профиль.ПолныйДоступКCOMОбъектам = Ложь;
	Профиль.ПолныйДоступКВнешнимКомпонентам = Ложь;
	Профиль.ПолныйДоступКВнешнимМодулям = Ложь;
	Профиль.ПолныйДоступКПриложениямОперационнойСистемы = Ложь;
	Профиль.ПолныйДоступКИнтернетРесурсам = Ложь;
	
	Профиль.ПолныйДоступКПривилегированномуРежиму = Ложь;
	
	Менеджеры = МенеджерыРегистровРазрешений();
	
	Для Каждого КлючИЗначение Из Разрешения Цикл
		
		ТаблицаОбработана = Истина;
		
		Для Каждого Менеджер Из Менеджеры Цикл
			
			Если Менеджер.ТипXDTOПредставленияРазрешений() = ФабрикаXDTO.Тип(РаботаВБезопасномРежимеСлужебный.ПакетXDTOПредставленийРазрешений(), КлючИЗначение.Ключ) Тогда
				
				Таблица = КлючИЗначение.Значение;
				
				Для Каждого Строка Из Таблица Цикл
					
					Менеджер.ЗаполнитьСвойстваПрофиляБезопасностиВНотацииИнтерфейсаАдминистрирования(
						Строка, Профиль);
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не ТаблицаОбработана Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неизвестное имя типа разрешений: %1!'"), КлючИЗначение.Ключ);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Профиль;
	
КонецФункции

// Вовзращает операции администрирования, присутствующие в запросах на использование внешних ресурсов.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов на использование
//    внешних ресурсов.
//
// Возвращаемое значение: ТаблицаЗначений:
//                         * ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника, который
//                             используется в качестве внешнего модуля,
//                         * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений,
//                         * Имя - Строка - имя профиля безопасности,
//
Функция ОперацииАдминистрированияВЗапросах(Знач ИдентификаторыЗапросов) Экспорт
	
	Результат = Новый ТаблицаЗначений();
	Результат.Колонки.Добавить("ВнешнийМодуль");
	Результат.Колонки.Добавить("Операция", Новый ОписаниеТипов("ПеречислениеСсылка.ОперацииСНаборамиРазрешений"));
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	Запросы.ИдентификаторЗапроса КАК ИдентификаторЗапроса,
		|	Запросы.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
		|	Запросы.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля,
		|	Запросы.Операция КАК Операция,
		|	Запросы.Имя КАК Имя
		|ИЗ
		|	РегистрСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов КАК Запросы
		|ГДЕ
		|	Запросы.ИдентификаторЗапроса В(&Идентификаторы)";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Идентификаторы", ИдентификаторыЗапросов);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Строка = Результат.Добавить();
		Строка.ВнешнийМодуль = СсылкаИзРегистраРазрешений(
			Выборка.ТипПрограммногоМодуля, Выборка.ИдентификаторПрограммногоМодуля);
		Строка.Операция = Выборка.Операция;
		Строка.Имя = Выборка.Имя;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сериализация / десериализация запросов на использование внешних ресурсов
//

// Сериализует запросы на использование внешних ресурсов.
//
// Параметры:
//  Идентификаторы - Массив(УникальныйИдентификатор) - идентификаторы запросов на использование
//    внешних ресурсов, которые требуется сериализовать.
//
// Возвращаемое значение: Массив(Строка) - массив, содержащий сериализацию запросов разрешений.
//
Функция СериализоватьЗапросыДляОбработкиСВосстановлением(Знач Идентификаторы)
	
	Результат = Новый Массив();
	
	Для Каждого Идентификатор Из Идентификаторы Цикл
		
		Набор = РегистрыСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов.СоздатьНаборЗаписей();
		Набор.Отбор.ИдентификаторЗапроса.Установить(Идентификатор);
		Набор.Прочитать();
		
		Если Набор.Количество() > 0 Тогда
			
			ПотокЗаписи = Новый ЗаписьXML();
			ПотокЗаписи.УстановитьСтроку();
			СериализаторXDTO.ЗаписатьXML(ПотокЗаписи, Набор);
			Результат.Добавить(ПотокЗаписи.Закрыть());
			
		КонецЕсли;
		
		Набор = РегистрыСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов.СоздатьНаборЗаписей();
		Набор.Отбор.ИдентификаторЗапроса.Установить(Идентификатор);
		Набор.Прочитать();
		
		Если Набор.Количество() > 0 Тогда
			
			ПотокЗаписи = Новый ЗаписьXML();
			ПотокЗаписи.УстановитьСтроку();
			СериализаторXDTO.ЗаписатьXML(ПотокЗаписи, Набор);
			Результат.Добавить(ПотокЗаписи.Закрыть());
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(Результат);
	
КонецФункции

// Десериализует запросы на использование внешних ресурсов и записывает их в информационную базу.
//
// Параметры:
//  Сериаилазция - Массив(Строка) - см. СериализоватьЗапросыДляОбработкиСВосстановлением().
//
Процедура ДесериализоватьЗапросыДляОбработкиСВосстановлением(Знач Сериализация)
	
	Для Каждого ЭлементСериализации Из Сериализация Цикл
		
		ПотокЧтения = Новый ЧтениеXML();
		ПотокЧтения.УстановитьСтроку(ЭлементСериализации);
		ПотокЧтения.ПерейтиКСодержимому();
		
		Набор = СериализаторXDTO.ПрочитатьXML(ПотокЧтения);
		Набор.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Лоигка работы мастера настройки разрешений на использование внешних ресурсов
//

// Выполняет обработку запросов на использование внешних ресурсов при инициализации
// мастера настройки разрешений.
//
// Параметры:
//  ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//    применения которых инициализируется мастер,
//  АдресВременногоХранилища - Строка - адрес временного хранилища, по которому должен быть
//    помещен результат обработки запросов на использование внешних ресурсов.
//
// Результатом вызова процедуры является помещение по переданному адресу временного хранилища
// структуры:
//  * ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//      применения которых инициализирован мастер,
//  * Представление - ТабличныйДокумент - представление изменений в разрешениях на использование
//      внешних ресурсов, которые должны быть внесены в настройки профилей безопасности в кластере
//      серверов.
//  * Сценарий - Массив(Структура) - сценарий внесения изменений в настройки профилей безопасности
//      в кластере серверов, который должен быть выполнен для применения запросов. Значениями массива
//      являются структуры со следующими полями:
//        * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую
//            требуется выполнить,
//        * Профиль - Строка, имя профиля безопасности,
//        * Разрешения - Структура - описание свойств профиля безопасности, см.
//            АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Процедура ВыполнитьОбработкуЗапросов(Знач ИдентификаторыЗапросов, АдресВременногоХранилища) Экспорт
	
	ОперацииАдминистрирования = ОперацииАдминистрированияВЗапросах(ИдентификаторыЗапросов);
	Дельта = ДельтаИзмененийРазрешенийНаИспользованиеВнешнихРесурсов(ИдентификаторыЗапросов);
	
	Результат = Новый Структура();
	
	Результат.Вставить("ИдентификаторыЗапросов", ИдентификаторыЗапросов);
	Результат.Вставить("Представление", Отчеты.ИспользуемыеВнешниеРесурсы.ПредставлениеРезультатаПримененияЗапросовНаИспользованиеВнешнихРесурсов(ОперацииАдминистрирования, Дельта));
	Результат.Вставить("Сценарий", СценарийПримененияЗапросовНаИзменениеДоступаКВнешнимРесурсам(ИдентификаторыЗапросов));
	
	ПоместитьВоВременноеХранилище(Результат, АдресВременногоХранилища);
	
КонецПроцедуры

// Выполняет обработку запросов на использование внешних ресурсов после обновления конфигурации
// (или при первоначальном включении профилей безопасности).
//
// Параметры:
//  АдресВременногоХранилища - Строка - адрес временного хранилища, по которому должен быть
//    помещен результат обработки запросов на использование внешних ресурсов.
//
// Результатом вызова процедуры является помещение по переданному адресу временного хранилища
// структуры:
//  * ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//      применения которых инициализирован мастер,
//  * Представление - ТабличныйДокумент - представление изменений в разрешениях на использование
//      внешних ресурсов, которые должны быть внесены в настройки профилей безопасности в кластере
//      серверов.
//  * Сценарий - Массив(Структура) - сценарий внесения изменений в настройки профилей безопасности
//      в кластере серверов, который должен быть выполнен для применения запросов. Значениями массива
//      являются структуры со следующими полями:
//        * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую
//            требуется выполнить,
//        * Профиль - Строка, имя профиля безопасности,
//        * Разрешения - Структура - описание свойств профиля безопасности, см.
//            АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Процедура ВыполнитьОбработкуЗапросовОбновления(АдресВременногоХранилища) Экспорт
	
	ВызовПриОтключенныхПрофилях = Не Константы.АвтоматическиНастраиватьРазрешенияВПрофиляхБезопасности.Получить();
	
	Если ВызовПриОтключенныхПрофилях Тогда
		
		НачатьТранзакцию();
		
		Константы.ИспользуютсяПрофилиБезопасности.Установить(Истина);
		Константы.АвтоматическиНастраиватьРазрешенияВПрофиляхБезопасности.Установить(Истина);
		
		ИдентификаторыЗапросов = РаботаВБезопасномРежимеСлужебный.ЗапросыНаОбновлениеРазрешенийКонфигурации();
		СериализацияЗапросов = СериализоватьЗапросыДляОбработкиСВосстановлением(ИдентификаторыЗапросов);
		
	КонецЕсли;
	
	ВыполнитьОбработкуЗапросов(ИдентификаторыЗапросов, АдресВременногоХранилища);
	
	Если ВызовПриОтключенныхПрофилях Тогда
		
		ОтменитьТранзакцию();
		ДесериализоватьЗапросыДляОбработкиСВосстановлением(СериализацияЗапросов);
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет обработку запросов на отключение использования профилей безопасности для информационной базы.
//
// Параметры:
//  АдресВременногоХранилища - Строка - адрес временного хранилища, по которому должен быть
//    помещен результат обработки запросов на использование внешних ресурсов.
//
// Результатом вызова процедуры является помещение по переданному адресу временного хранилища
// структуры:
//  * ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//      применения которых инициализирован мастер,
//  * Представление - ТабличныйДокумент - представление изменений в разрешениях на использование
//      внешних ресурсов, которые должны быть внесены в настройки профилей безопасности в кластере
//      серверов.
//  * Сценарий - Массив(Структура) - сценарий внесения изменений в настройки профилей безопасности
//      в кластере серверов, который должен быть выполнен для применения запросов. Значениями массива
//      являются структуры со следующими полями:
//        * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую
//            требуется выполнить,
//        * Профиль - Строка, имя профиля безопасности,
//        * Разрешения - Структура - описание свойств профиля безопасности, см.
//            АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Процедура ВыполнитьОбработкуЗапросовОтключения(АдресВременногоХранилища) Экспорт
	
	Запросы = ЗапросыНаОтключениеПрофилейБезопасности();
	ВыполнитьОбработкуЗапросов(Запросы, АдресВременногоХранилища);
	
КонецПроцедуры

// Выполняет обработку запросов на восстановление настроек профилей безопасности в кластре серверов
// по текущему состоянию информационной базы.
//
// Параметры:
//  АдресВременногоХранилища - Строка - адрес временного хранилища, по которому должен быть
//    помещен результат обработки запросов на использование внешних ресурсов.
//
// Результатом вызова процедуры является помещение по переданному адресу временного хранилища
// структуры:
//  * ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//      применения которых инициализирован мастер,
//  * Представление - ТабличныйДокумент - представление изменений в разрешениях на использование
//      внешних ресурсов, которые должны быть внесены в настройки профилей безопасности в кластере
//      серверов.
//  * Сценарий - Массив(Структура) - сценарий внесения изменений в настройки профилей безопасности
//      в кластере серверов, который должен быть выполнен для применения запросов. Значениями массива
//      являются структуры со следующими полями:
//        * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую
//            требуется выполнить,
//        * Профиль - Строка, имя профиля безопасности,
//        * Разрешения - Структура - описание свойств профиля безопасности, см.
//            АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Процедура ВыполнитьОбработкуЗапросовВосстановления(АдресВременногоХранилища) Экспорт
	
	НачатьТранзакцию();
	
	ОчиститьПредоставленныеРазрешения(, Ложь);
	
	ИдентификаторыЗапросов = РаботаВБезопасномРежимеСлужебный.ЗапросыНаОбновлениеРазрешенийКонфигурации(Ложь);
	
	СериализацияЗапросов = СериализоватьЗапросыДляОбработкиСВосстановлением(ИдентификаторыЗапросов);
	
	ВыполнитьОбработкуЗапросов(ИдентификаторыЗапросов, АдресВременногоХранилища);
	
	ОтменитьТранзакцию();
	
	ДесериализоватьЗапросыДляОбработкиСВосстановлением(СериализацияЗапросов);
	
КонецПроцедуры

// Выполняет обработку запросов на проверку завершения операции, в рамках которой ранее были выполнено
// применение запросов на использование внешних ресурсов.
//
// Параметры:
//  АдресВременногоХранилища - Строка - адрес временного хранилища, по которому должен быть
//    помещен результат обработки запросов на использование внешних ресурсов.
//
// Результатом вызова процедуры является помещение по переданному адресу временного хранилища
// структуры:
//  * ИдентификаторыЗапросов - Массив(УникальныйИдентификатор) - идентификаторы запросов, для
//      применения которых инициализирован мастер,
//  * Представление - ТабличныйДокумент - представление изменений в разрешениях на использование
//      внешних ресурсов, которые должны быть внесены в настройки профилей безопасности в кластере
//      серверов.
//  * Сценарий - Массив(Структура) - сценарий внесения изменений в настройки профилей безопасности
//      в кластере серверов, который должен быть выполнен для применения запросов. Значениями массива
//      являются структуры со следующими полями:
//        * Операция - ПеречислениеСсылка.ОперацииСНаборамиРазрешений - операция, которую
//            требуется выполнить,
//        * Профиль - Строка, имя профиля безопасности,
//        * Разрешения - Структура - описание свойств профиля безопасности, см.
//            АдминистрированиеКластераКлиентСервер.СвойстваПрофиляБезопасности().
//
Процедура ВыполнитьОбработкуЗапросовПроверкиПрименения(АдресВременногоХранилища) Экспорт
	
	ИдентификаторыЗапросов = Новый Массив();
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ИдентификаторыЗапросов, ЗапросыЗамещенияДляВсехПредоставленныхРазрешений());
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ИдентификаторыЗапросов, РаботаВБезопасномРежимеСлужебный.ЗапросыНаОбновлениеРазрешенийКонфигурации(Ложь));
	
	ВыполнитьОбработкуЗапросов(ИдентификаторыЗапросов, АдресВременногоХранилища);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Внешние модули
//

// Возвращает режим подключения внешнего модуля.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка, ссылка, соответствующая внешнему модулю, для которого запрашиваются
//    режим подключения.
//
// Возвращаемое значение: Строка - имя профиля безопасности, который должен использоваться для подключения
//  внешнего модуля. Если для внешнего модуля не зарегистрирован режим подключения - возвращается Неопределено.
//
Функция РежимПодключенияВнешнегоМодуля(Знач ВнешнийМодуль) Экспорт
	
	Если РаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
		
		Возврат БезопасныйРежим();
		
	Иначе
		
		УстановитьПривилегированныйРежим(Истина);
		
		СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(ВнешнийМодуль);
		
		Менеджер = РегистрыСведений.РежимыПодключенияВнешнихМодулей.СоздатьМенеджерЗаписи();
		Менеджер.ТипПрограммногоМодуля = СвойстваПрограммногоМодуля.Тип;
		Менеджер.ИдентификаторПрограммногоМодуля = СвойстваПрограммногоМодуля.Идентификатор;
		Менеджер.Прочитать();
		Если Менеджер.Выбран() Тогда
			Возврат Менеджер.БезопасныйРежим;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочее
//

// Формирует имя профиля безопасности для информационной базы или внешнего модуля.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника, использующийся в
//    качестве внешнего модуля.
//
// Вовзращаемое значение: Строка - имя профиля безопасности.
//
Функция НовоеИмяПрофиляБезопасности(Знач ВнешнийМодуль)
	
	Если ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		
		Результат = "Infobase_" + Строка(Новый УникальныйИдентификатор());
		
	Иначе
		
		ВнешнийМодуль = ВнешнийМодуль;
		
		МенеджерМодуля = РаботаВБезопасномРежимеСлужебный.МенеджерВнешнегоМодуля(ВнешнийМодуль);
		Шаблон = МенеджерМодуля.ШаблонИмениПрофиляБезопасности(ВнешнийМодуль);
		Возврат СтрЗаменить(Шаблон, "%1", Строка(Новый УникальныйИдентификатор()));
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует описание профиля безопасности для информационной базы или внешнего модуля.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника, использующийся в
//    качестве внешнего модуля.
//
// Вовзращаемое значение: Строка - описание профиля безопасности.
//
Функция НовоеОписаниеПрофиляБезопасности(Знач ВнешнийМодуль) Экспорт
	
	Шаблон = НСтр("ru = '[ИБ %1] %2 ""%3""'");
	
	ИмяИБ = "";
	СтрокаСоединения = СтрокаСоединенияИнформационнойБазы();
	Подстроки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаСоединения, ";");
	Для Каждого Подстрока Из Подстроки Цикл
		Если Лев(Подстрока, 3) = "Ref" Тогда
			ИмяИБ = СтрЗаменить(Прав(Подстрока, СтрДлина(Подстрока) - 4), """", "");
		КонецЕсли;
	КонецЦикла;
	Если ПустаяСтрока(ИмяИБ) Тогда
		ВызватьИсключение НСтр("ru = 'Строка соединения информационной базы не содержит имени информационной базы!'");
	КонецЕсли;
	
	Если ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, ИмяИБ,
			НСтр("ru = 'Основной профиль безопасности для информационной базы'"), СтрокаСоединенияИнформационнойБазы());
	Иначе
		Словарь = РаботаВБезопасномРежимеСлужебный.МенеджерВнешнегоМодуля(ВнешнийМодуль).СловарьКонтейнераВнешнегоМодуля();
		НаименованиеМодуля = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВнешнийМодуль, "Наименование");
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, ИмяИБ, Словарь.Именительный, НаименованиеМодуля);
	КонецЕсли;
	
КонецФункции

// Возвращает имя профиля безопасности для информационной базы или внешнего модуля.
//
// Параметры:
//  ВнешнийМодуль - ЛюбаяСсылка - ссылка на элемент справочника, использующийся в
//    качестве внешнего модуля.
//
// Вовзращаемое значение: Строка - имя профиля безопасности.
//
Функция ИмяПрофиляБезопасности(Знач ВнешнийМодуль) Экспорт
	
	Если ВнешнийМодуль = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		
		Возврат Константы.ПрофильБезопасностиИнформационнойБазы.Получить();
		
	Иначе
		
		Возврат РежимПодключенияВнешнегоМодуля(ВнешнийМодуль);
		
	КонецЕсли;
	
КонецФункции

// Проверяет, что профиль безопасности назначен внешнему модулю.
//
// Параметры:
//  ИмяПрофиля - Строка - имя профиля безопасности.
//
// Возвращаемое значение: Булево.
//
Функция ПрофильБезопасностиНазначенВнешнемуМодулю(Знач ИмяПрофиля)
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|	РежимыПодключенияВнешнихМодулей.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
		|	РежимыПодключенияВнешнихМодулей.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля
		|ИЗ
		|	РегистрСведений.РежимыПодключенияВнешнихМодулей КАК РежимыПодключенияВнешнихМодулей
		|ГДЕ
		|	РежимыПодключенияВнешнихМодулей.БезопасныйРежим = &БезопасныйРежим";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("БезопасныйРежим", ИмяПрофиля);
	РезультатЗапроса = Запрос.Выполнить();
	Возврат Не РезультатЗапроса.Пустой();
	
КонецФункции

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - См. ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления().
//
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.2.31";
	Обработчик.Процедура = "Обработки.НастройкаРазрешенийНаИспользованиеВнешнихРесурсов.ЗаполнитьВнешнийМодульДляПредоставленныхРазрешений";
	Обработчик.ОбщиеДанные = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.3.23";
	Обработчик.Процедура = "Обработки.НастройкаРазрешенийНаИспользованиеВнешнихРесурсов.ЗаполнитьТипыИИдентификаторыВРегистрахРазрешений";
	Обработчик.ОбщиеДанные = Истина;
	
КонецПроцедуры

// Формирует параметры для хранения ссылки в регистрах разрешений.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка.
//
// Возвращаемое значение: Структура:
//                        * Тип - СправочникСсылка.ИдентификаторыОбъектовМетаданных,
//                        * Идентификатор - Строка, в которой хранится приведенный к строке
//                            уникальный идентификатор ссылки.
//
Функция СвойстваДляРегистраРазрешений(Знач Ссылка) Экспорт
	
	Результат = Новый Структура("Тип,Идентификатор");
	
	Если Ссылка = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		
		Результат.Тип = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
		Результат.Идентификатор = "";
		
	Иначе
		
		Результат.Тип = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(Ссылка.Метаданные());
		Результат.Идентификатор = Строка(Ссылка.УникальныйИдентификатор());
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует ссылку из данных, хранящихся в регистрах разрешений.
//
// Параметры:
//  Тип - СправочникСсылка.ИдентификаторОбъектаМетаданных,
//  Идентификатор - Строка, в которой хранится приведенный к строке уникальный идентификатор ссылки.
//
// Возвращаемое значение: ЛюбаяСсылка.
//
Функция СсылкаИзРегистраРазрешений(Знач Тип, Знач Идентификатор)
	
	Если Тип = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		Возврат Тип;
	Иначе
		
		ОбъектМетаданных = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(Тип);
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
		
		Если ПустаяСтрока(Идентификатор) Тогда
			Возврат Менеджер.ПустаяСсылка();
		Иначе
			УникальныйИдентификатор = Новый УникальныйИдентификатор(Идентификатор);
			Возврат Менеджер.ПолучитьСсылку(УникальныйИдентификатор);
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики обновления
//

// [2.2.2.31] Процедура проставляет значение измерения ВнешнийМодуль у регистров, используемых в качестве
// кэша предоставленных разрешений.
//
Процедура ЗаполнитьВнешнийМодульДляПредоставленныхРазрешений() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных();
		
		Регистры = МенеджерыРегистровРазрешений();
		Для Каждого Регистр Из Регистры Цикл
			Блокировка.Добавить(Регистр.СоздатьНаборЗаписей().Метаданные().ПолноеИмя());
		КонецЦикла;
		
		Блокировка.Добавить("РегистрСведений.РежимыПодключенияВнешнихМодулей");
		
		Блокировка.Заблокировать();
		
		СоответствиеРежимовМодулям = Новый ТаблицаЗначений();
		СоответствиеРежимовМодулям.Колонки.Добавить("БезопасныйРежим", Метаданные.ОпределяемыеТипы.БезопасныйРежим.Тип);
		СоответствиеРежимовМодулям.Колонки.Добавить("ТипПрограммногоМодуля", Новый ОписаниеТипов("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
		СоответствиеРежимовМодулям.Колонки.Добавить("ИдентификаторПрограммногоМодуля", Новый ОписаниеТипов("Строка"));
		
		МодульКонфигурации = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
		СтрокаКонфигурации = СоответствиеРежимовМодулям.Добавить();
		СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		СтрокаКонфигурации.ТипПрограммногоМодуля = СвойстваПрограммногоМодуля.Тип;
		СтрокаКонфигурации.ИдентификаторПрограммногоМодуля = СвойстваПрограммногоМодуля.Идентификатор;
		СтрокаКонфигурации.БезопасныйРежим = ИмяПрофиляБезопасности(Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		
		ТекстЗапроса =
			"ВЫБРАТЬ
			|	РежимыПодключенияВнешнихМодулей.ТипПрограммногоМодуля КАК ТипПрограмнмогоМодуля,
			|	РежимыПодключенияВнешнихМодулей.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля,
			|	РежимыПодключенияВнешнихМодулей.БезопасныйРежим КАК БезопасныйРежим
			|ИЗ
			|	РегистрСведений.РежимыПодключенияВнешнихМодулей КАК РежимыПодключенияВнешнихМодулей";
		Запрос = Новый Запрос(ТекстЗапроса);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			СтрокаМодуля = СоответствиеРежимовМодулям.Добавить();
			СтрокаМодуля.ТипПрограммногоМодуля = Выборка.ТипПрограммногоМодуля;
			СтрокаМодуля.ИдентификаторПрограммногоМодуля = Выборка.ИдентификаторПрограммногоМодуля;
			СтрокаМодуля.БезопасныйРежим = Выборка.БезопасныйРежим;
		КонецЦикла;
		
		Для Каждого Регистр Из Регистры Цикл
			
			ТекстЗапросаСозданияВТ =
				"ВЫБРАТЬ
				|	Соответствие.БезопасныйРежим КАК БезопасныйРежим,
				|	Соответствие.ТипПрограммногоМодуля КАК ТипПрограммногоМодуля,
				|	Соответствие.ИдентификаторПрограммногоМодуля КАК ИдентификаторПрограммногоМодуля
				|ПОМЕСТИТЬ Соответствие
				|ИЗ
				|	&Соответствие КАК Соответствие";
			
			Запрос = Новый Запрос(ТекстЗапросаСозданияВТ);
			Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц();
			Запрос.УстановитьПараметр("Соответствие", СоответствиеРежимовМодулям);
			Запрос.Выполнить();
			
			МетаданныеРегистра = Регистр.СоздатьНаборЗаписей().Метаданные();
			
			ТекстЗапросаРезультата = "Выбрать [ПоляРегистра], Соответствие.ТипПрограммногоМодуля, Соответствие.ИдентификаторПрограммногоМодуля Из [ТаблицаРегистра] КАК ТаблицаРегистра ЛЕВОЕ СОЕДИНЕНИЕ Соответствие По ТаблицаРегистра.БезопасныйРежим = Соответствие.БезопасныйРежим";
			
			ИмяТаблицы = МетаданныеРегистра.ПолноеИмя();
			ПсевдонимТаблицы = "ТаблицаРегистра";
			
			ПоляРегистра = "";
			Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
				Если Не ПустаяСтрока(ПоляРегистра) Тогда
					ПоляРегистра = ПоляРегистра + ", ";
				КонецЕсли;
				ПоляРегистра = ПоляРегистра + ПсевдонимТаблицы + "." + Измерение.Имя + " КАК " + Измерение.Имя;
			КонецЦикла;
			Для Каждого Ресурс Из МетаданныеРегистра.Ресурсы Цикл
				Если Не ПустаяСтрока(ПоляРегистра) Тогда
					ПоляРегистра = ПоляРегистра + ", ";
				КонецЕсли;
				ПоляРегистра = ПоляРегистра + ПсевдонимТаблицы + "." + Ресурс.Имя + " КАК " + Ресурс.Имя;
			КонецЦикла;
			Для Каждого Реквизит Из МетаданныеРегистра.Реквизиты Цикл
				Если Не ПустаяСтрока(ПоляРегистра) Тогда
					ПоляРегистра = ПоляРегистра + ", ";
				КонецЕсли;
				ПоляРегистра = ПоляРегистра + ПсевдонимТаблицы + "." + Реквизит.Имя + " КАК " + Реквизит.Имя;
			КонецЦикла;
			
			ТекстЗапросаРезультата = СтрЗаменить(ТекстЗапросаРезультата, "[ТаблицаРегистра]", ИмяТаблицы);
			ТекстЗапросаРезультата = СтрЗаменить(ТекстЗапросаРезультата, "[ПоляРегистра]", ПоляРегистра);
			
			Запрос.Текст = ТекстЗапросаРезультата;
			СодержимоеРегистра = Запрос.Выполнить().Выгрузить();
			Набор = Регистр.СоздатьНаборЗаписей();
			Набор.Загрузить(СодержимоеРегистра);
			Набор.Записать();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// [2.2.3.23] Процедура заполняет типы и идентификаторы программных модулей и владельцев разрешений в
// регистрах разрешений.
//
Процедура ЗаполнитьТипыИИдентификаторыВРегистрахРазрешений() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		СлужебныйИОМ = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
			Метаданные.РегистрыСведений.РежимыПодключенияВнешнихМодулей);
		
		ОчисткаНеактуальныхЗапросовНаИспользованиеВнешнихРесурсов();
		
		План = Новый Соответствие();
		
		План.Вставить(РегистрыСведений.ЗапросыАдминистрированияРазрешенийИспользованияВнешнихРесурсов, "ВнешнийМодуль");
		План.Вставить(РегистрыСведений.ЗапросыРазрешенийНаИспользованиеВнешнихРесурсов, "ВнешнийМодуль,Владелец");
		План.Вставить(РегистрыСведений.РежимыПодключенияВнешнихМодулей, "ВнешнийМодуль");
		
		Для Каждого МенеджерРегистра Из МенеджерыРегистровРазрешений() Цикл
			План.Вставить(МенеджерРегистра, "ВнешнийМодуль,Владелец");
		КонецЦикла;
		
		Для Каждого СтрокаПлана Из План Цикл
			
			Регистр = СтрокаПлана.Ключ;
			Поля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПлана.Значение, ",");
			
			Выборка = Регистр.Выбрать();
			Пока Выборка.Следующий() Цикл
				
				МенеджерЗаписи = Выборка.ПолучитьМенеджерЗаписи();
				МенеджерЗаписи.Прочитать();
				
				Для Каждого Поле Из Поля Цикл
					
					Если Поле = "Владелец" Тогда
						
						Ссылка = МенеджерЗаписи.ТипВладельца;
						
						Если ЗначениеЗаполнено(Ссылка) И Не ЗначениеЗаполнено(МенеджерЗаписи.ИдентификаторВладельца) Тогда
							
							Если Ссылка <> СлужебныйИОМ Тогда
								СвойстваВладельца = СвойстваДляРегистраРазрешений(Ссылка);
								МенеджерЗаписи.ТипВладельца = СвойстваВладельца.Тип;
								МенеджерЗаписи.ИдентификаторВладельца = СвойстваВладельца.Идентификатор;
							Иначе
								МенеджерЗаписи.ТипВладельца = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
								МенеджерЗаписи.ИдентификаторВладельца = "";
							КонецЕсли;
							
						КонецЕсли;
						
					ИначеЕсли Поле = "ВнешнийМодуль" Тогда
						
						Ссылка = МенеджерЗаписи.ТипПрограммногоМодуля;
						
						Если ЗначениеЗаполнено(Ссылка) И Не ЗначениеЗаполнено(МенеджерЗаписи.ИдентификаторПрограммногоМодуля) Тогда
							
							Если Ссылка <> СлужебныйИОМ Тогда
								СвойстваПрограммногоМодуля = СвойстваДляРегистраРазрешений(Ссылка);
								МенеджерЗаписи.ТипПрограммногоМодуля = СвойстваПрограммногоМодуля.Тип;
								МенеджерЗаписи.ИдентификаторПрограммногоМодуля = СвойстваПрограммногоМодуля.Идентификатор;
							Иначе
								МенеджерЗаписи.ТипПрограммногоМодуля = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
								МенеджерЗаписи.ИдентификаторПрограммногоМодуля = "";
							КонецЕсли;
							
						КонецЕсли;
						
					КонецЕсли;
					
					МенеджерЗаписи.Записать();
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#КонецЕсли

