////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Реквизиты, ",", Истина);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(Знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В(&МассивДокументов)
		|	И НЕ ПсевдонимЗаданнойТаблицы.Проведен";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		МетаданныеДокумента = Документ.Метаданные();
		Если ИменаДокументов.Найти(МетаданныеДокумента.ПолноеИмя()) = Неопределено
			И Метаданные.Документы.Содержит(МетаданныеДокумента)
			И МетаданныеДокумента.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				ИменаДокументов.Добавить(МетаданныеДокумента.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//			 Ссылка         - документ, который не удалось провести;
//			 ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будут учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
//  ДругиеИсключения - Массив полных имен объектов метаданных, которые также
//                 требуется исключить из поиска ссылок.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСсылкиНаОбъект(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь,  ДругиеИсключения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	ТаблицаСсылок.Колонки[0].Имя = "ИсходнаяСсылка";
	ТаблицаСсылок.Колонки[1].Имя = "ОбнаруженныйСсылка";
	ТаблицаСсылок.Колонки[2].Имя = "ОбнаруженныйМетаданные";
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ДругиеИсключения) = Тип("Массив") Тогда
		ИсключенияПоискаСсылок = Новый Соответствие;
		Исключения = Новый Массив;
		
		Для каждого ПолноеИмя Из ДругиеИсключения Цикл
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
			Если ОбъектМетаданных <> Неопределено Тогда
				ИсключенияПоискаСсылок.Вставить(ОбъектМетаданных, "*");
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаСсылок.Количество() > 0;
	
КонецФункции

// Производит замену ссылок по всей конфигурации. После замены неиспользуемые ссылки опционально удаляются.
// Замена ссылок происходит с транзакциями по изменяемому объекту и его связям, не по анализируемой ссылке.
//
// Параметры:
//
//     ПарыЗамен - Соответствие - Ключ - искомая ссылка, Значение - ссылка для замены. Ссылки сами на себя и пустые 
//                                ссылки для поиска будут проигнорированы.
//
//     Параметры - Структура    - Параметры замены. Может включать поля:
//
//                                * СпособУдаления - Строка, маркер способа удаления. Может принимать значения:
//                                      "Непосредственно" - Если после замены ссылка нигде не используется,
//                                                          то она будет удалена непосредственно
//                                      "Пометка"         - Если после замены ссылка не используется, то 
//                                                          она будет помечена на удаление
//                                      Любые другие значения отменяют необходимость удаления.
//                                      Значение по умолчанию - пустая строка.
//
//                                * ВключатьБизнесЛогику  - Булево, флаг необходимость включения бизнес логики при записи объектов
//                                                          Значение по умолчанию - Истина
//
//                                * ЗаменаПарыВТранзакции - Булево - при значении Истина транзакция охватывает все производимые замены для одной пары ссылок.
//                                                          Ложь - каждая замена ссылки в одном объекте выполняется в отдельной транзакции.
//                                                          Значение по умолчанию - Истина
//
//                                * ПривилегированнаяЗапись - Булево - При значении Истина запись происходит в привилегированном режиме, иначе - с текущими правами
//                                                            Значение по умолчанию - Ложь
//
//     АдресРезультата - Строка - Необязательный адрес во временном хранилище, куда будет помещен копия результата замены
//
// Возвращаемое значение - ТаблицаЗначений - описание неуспешных замен (ошибок) с колонками:
//
//     * Ссылка - ЛюбаяСсылка - Ссылка, которую заменяли
//     * ОбъектОшибки - Произвольный - Объект - причина ошибки
//     * ПредставлениеОбъектаОшибки - Строка - Строковое представление объекта ошибки
//     * ТипОшибки - Строка - Маркер типа ошибки. Возможны варианты:
//                             "ОшибкаБлокировки"  - при обработке ссылки некоторые объекты были заблокированы
//                             "ДанныеИзменены"    - в процессе обработки данные были изменены другим пользователем
//                             "ОшибкаЗаписи"      - не смогли записать объект
//                             "НеизвестныеДанные" - при обработке были найдены данные, которые
//                                                   не планировались к анализу, замена не реализована
//     * ТекстОшибки - Строка - Подробное описание ошибки
//
Функция ЗаменитьСсылки(Знач ПарыЗамен, Знач Параметры = Неопределено, Знач АдресРезультата = "") Экспорт
	
	// Умолчания
	ПараметрыЗамены = Новый Структура;
	ПараметрыЗамены.Вставить("УдалятьНепосредственно",  Ложь); 
	ПараметрыЗамены.Вставить("ПомечатьНаУдаление",      Ложь); 
	ПараметрыЗамены.Вставить("КонтрольПриЗаписи",       Истина); 
	ПараметрыЗамены.Вставить("ПривилегированнаяЗапись", Ложь);
	
	ДлиннаяТранзакция = Истина;
	
	Если Параметры <> Неопределено Тогда
		ЗначениеПараметра = Неопределено;
		
		Если Параметры.Свойство("СпособУдаления", ЗначениеПараметра) Тогда
			Если ЗначениеПараметра = "Непосредственно" Тогда
				ПараметрыЗамены.УдалятьНепосредственно = Истина;
				ПараметрыЗамены.ПомечатьНаУдаление     = Ложь;
			ИначеЕсли ЗначениеПараметра = "Пометка" Тогда
				ПараметрыЗамены.УдалятьНепосредственно = Ложь;
				ПараметрыЗамены.ПомечатьНаУдаление     = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если Параметры.Свойство("ВключатьБизнесЛогику", ЗначениеПараметра) Тогда
			Если ЗначениеПараметра = Истина Тогда
				ПараметрыЗамены.КонтрольПриЗаписи = Истина;
			ИначеЕсли ЗначениеПараметра = Ложь Тогда
				ПараметрыЗамены.КонтрольПриЗаписи = Ложь;
			КонецЕсли;
		КонецЕсли;
		
		Если Параметры.Свойство("ЗаменаПарыВТранзакции", ЗначениеПараметра) Тогда
			Если ЗначениеПараметра = Истина Тогда
				ДлиннаяТранзакция = Истина;
			ИначеЕсли ЗначениеПараметра = Ложь Тогда
				ДлиннаяТранзакция = Ложь;
			КонецЕсли;
		КонецЕсли;
		
		Если Параметры.Свойство("ПривилегированнаяЗапись", ЗначениеПараметра) Тогда
			Если ЗначениеПараметра = Истина Тогда
				ПараметрыЗамены.ПривилегированнаяЗапись = Истина;
			ИначеЕсли ЗначениеПараметра = Ложь Тогда
				ПараметрыЗамены.ПривилегированнаяЗапись = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	ТипСтрока = Новый ОписаниеТипов("Строка");

	РезультатЗамены = Новый ТаблицаЗначений;
	РезультатЗамены.Колонки.Добавить("Ссылка");
	РезультатЗамены.Колонки.Добавить("ОбъектОшибки");
	РезультатЗамены.Колонки.Добавить("ПредставлениеОбъектаОшибки", ТипСтрока);
	РезультатЗамены.Колонки.Добавить("ТипОшибки", ТипСтрока);
	РезультатЗамены.Колонки.Добавить("ТекстОшибки", ТипСтрока);
	РезультатЗамены.Индексы.Добавить("Ссылка");
	РезультатЗамены.Индексы.Добавить("Ссылка, ОбъектОшибки, ТипОшибки");
	
	КэшМетаданных = Новый Соответствие;
	
	СписокСсылок = Новый Массив;
	Для Каждого КлючЗначение Из ПарыЗамен Цикл
		ТекущаяСсылка = КлючЗначение.Ключ;
		ЦелеваяСсылка = КлючЗначение.Значение;
		
		Если ТекущаяСсылка = ЦелеваяСсылка Или ТекущаяСсылка.Пустая() Тогда
			// Самого на себя и пустые ссылки не заменяем
			Продолжить;
		КонецЕсли;
		
		СписокСсылок.Добавить(ТекущаяСсылка);
	КонецЦикла;
	
	ТаблицаПоиска = МестаИспользования(СписокСсылок);
	
	// Для каждой ссылки объекта будем производить замены в порядке "Константа", "Объект", "Набор".
	// Одновременно пустая строка в этой колонке - флаг того, что эта замена не нужна или уже была произведена
	ТаблицаПоиска.Колонки.Добавить("КлючЗамены", ТипСтрока);
	ТаблицаПоиска.Индексы.Добавить("Ссылка, КлючЗамены");
	ТаблицаПоиска.Индексы.Добавить("Данные, КлючЗамены");
	
	// Вспомогательные данные
	ТаблицаПоиска.Колонки.Добавить("ЦелеваяСсылка");
	
	Конфигурация = Новый Структура;
	Конфигурация.Вставить("ТипВсеСсылки",   ОписаниеТипаВсеСсылки() );
	Конфигурация.Вставить("МетаКонстанты",  Метаданные.Константы);
	Конфигурация.Вставить("ТипКлючЗаписи",  ОписаниеТипаКлючиЗаписей() );
	
	// Определяем порядок обработки и проверяем то, что мы можем обработать
	ПроизводимыеЗамены = Новый Массив;
	Для Каждого ТекущаяСсылка Из СписокСсылок Цикл
		ЦелеваяСсылка = ПарыЗамен[ТекущаяСсылка];
		
		РезультатРазметки = Неопределено; 
		РазметитьМестаИспользования(Конфигурация, ТекущаяСсылка, ЦелеваяСсылка, ТаблицаПоиска, РезультатРазметки);
		
		Если РезультатРазметки.ОшибкиРазметки.Количество() = 0 Тогда
			ПроизводимыеЗамены.Добавить(ТекущаяСсылка);
			
		Иначе
			// Найдены неизвестные типы замены, не будем работать с этой ссылкой, возможно нарушение связности
			Для Каждого Ошибка Из РезультатРазметки.ОшибкиРазметки Цикл
				ПредставлениеОбъектаОшибки = Строка(Ошибка.Объект);
				ДобавитьРезультатЗамены(РезультатЗамены, ТекущаяСсылка, 
					ОписаниеОшибкиЗамены("НеизвестныеДанные", Ошибка.Объект, ПредставлениеОбъектаОшибки, Ошибка.Текст)
				);
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ДлиннаяТранзакция Тогда
		Для Каждого Ссылка Из ПроизводимыеЗамены Цикл
			ЗаменитьСсылкуДлиннойТранзакцией(РезультатЗамены, Ссылка, ПараметрыЗамены, ТаблицаПоиска);
		КонецЦикла;
	Иначе
		ЗаменитьСсылкиКороткимиТранзакциями(РезультатЗамены, ПараметрыЗамены, ПроизводимыеЗамены, ТаблицаПоиска);
	КонецЕсли;
	
	Если Не ПустаяСтрока(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(РезультатЗамены, АдресРезультата);
	КонецЕсли;
	
	Возврат РезультатЗамены;
КонецФункции

// Получает все места использования ссылок.
// Если какая-либо ссылка нигде не используется, то строк для нее в результирующей таблице не будет.
//
// Параметры:
//     НаборСсылок     - Массив - Ссылки, для которых ищем места использования
//     АдресРезультата - Строка - Необязательный адрес во временном хранилище, куда будет помещен копия результата замены
// 
// Возвращаемое значение:
//     ТаблицаЗначений - Состоит из колонок:
//       * Ссылка                - ЛюбаяСсылка      - Ссылка, которая анализируется
//       * Данные                - Произвольный     - Данные, содержащие анализируемую ссылку
//       * Метаданные            - ОбъектМетаданных - Метаданные найденных данных
//       * ПредставлениеДанных   - Строка           - Представление данных, содержащих анализируемую ссылку
//       * ТипСсылки             - Тип              - Тип анализируемой ссылки
//       * ВспомогательныеДанные - Булево           - Истина, если данные используются анализируемой ссылкой как вспомогательными 
//                                                    данными (ведущее измерение и т.п.)
//
Функция МестаИспользования(Знач НаборСсылок, Знач АдресРезультата = "") Экспорт
	
	МестаИспользования = Новый ТаблицаЗначений;
	
	УстановитьПривилегированныйРежим(Истина);
	МестаИспользования = НайтиПоСсылкам(НаборСсылок);
	
	МестаИспользования.Колонки.Добавить("ПредставлениеДанных", Новый ОписаниеТипов("Строка"));
	МестаИспользования.Колонки.Добавить("ТипСсылки");
	МестаИспользования.Колонки.Добавить("ВспомогательныеДанные", Новый ОписаниеТипов("Булево"));
	
	МестаИспользования.Индексы.Добавить("Ссылка");
	МестаИспользования.Индексы.Добавить("Данные");
	МестаИспользования.Индексы.Добавить("ВспомогательныеДанные");
	МестаИспользования.Индексы.Добавить("Ссылка, ВспомогательныеДанные");
	
	ТипКлючиЗаписей = ОписаниеТипаКлючиЗаписей();
	ТипВсеСсылки    = ОписаниеТипаВсеСсылки();
	
	МетаПоследовательности = Метаданные.Последовательности;
	МетаКонстанты          = Метаданные.Константы;
	МетаДокументы          = Метаданные.Документы;
	
	ВспомогательныеМетаданные = ПолучитьОбщийСписокИсключенийПоискаСсылок();
	
	КэшИзмерений = Новый Соответствие;
	
	Для Каждого Строка Из МестаИспользования Цикл
		Ссылка    = Строка.Ссылка;
		Данные    = Строка.Данные;
		Мета      = Строка.Метаданные;
		ТипДанных = ТипЗнч(Данные);
		
		ПутьВспомогательныхДанных = ВспомогательныеМетаданные[Мета];
		
		Если ПутьВспомогательныхДанных = Неопределено Тогда
			ЭтоВспомогательныеДанные = (Ссылка = Данные);
			
		ИначеЕсли ПутьВспомогательныхДанных = "*" Тогда
			ЭтоВспомогательныеДанные = Истина;
			
		ИначеЕсли ТипКлючиЗаписей.СодержитТип(ТипДанных) Тогда
			ЭтоВспомогательныеДанные = Ложь;
			Для Каждого СтрокаДанные Из Данные Цикл
				Если Ссылка = ВычислитьЗначениеДанныхПоПути(СтрокаДанные, ПутьВспомогательныхДанных) Тогда
					ЭтоВспомогательныеДанные = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			ЭтоВспомогательныеДанные = (Ссылка = ВычислитьЗначениеДанныхПоПути(Данные, ПутьВспомогательныхДанных) );
			
		КонецЕсли;
		
		Если МетаДокументы.Содержит(Мета) Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли МетаКонстанты.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + НСтр("ru = 'константа'") + ")";
			
		ИначеЕсли МетаПоследовательности.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + НСтр("ru = 'последовательность'") + ")";
			
		ИначеЕсли ТипДанных = Неопределено Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли ТипВсеСсылки.СодержитТип(ТипДанных) Тогда
			МетаПредставлениеОбъекта = Новый Структура("ПредставлениеОбъекта");
			ЗаполнитьЗначенияСвойств(МетаПредставлениеОбъекта, Мета);
			Если ПустаяСтрока(МетаПредставлениеОбъекта.ПредставлениеОбъекта) Тогда
				МетаПредставление = Мета.Представление();
			Иначе
				МетаПредставление = МетаПредставлениеОбъекта.ПредставлениеОбъекта;
			КонецЕсли;
			Представление = Строка(Данные);
			Если Не ПустаяСтрока(МетаПредставление) Тогда
				Представление = Представление + " (" + МетаПредставление + ")";
			КонецЕсли;
			
		ИначеЕсли ТипКлючиЗаписей.СодержитТип(ТипДанных) Тогда
			Представление = Мета.ПредставлениеЗаписи;
			Если ПустаяСтрока(Представление) Тогда
				Представление = Мета.Представление();
			КонецЕсли;
			
			ОписаниеИзмерений = "";
			Для Каждого КлючЗначение Из ОписаниеИзмеренийНабора(Мета, КэшИзмерений) Цикл
				Значение = Данные[КлючЗначение.Ключ];
				Описание = КлючЗначение.Значение;
				Если Значение = Ссылка Тогда
					Если Описание.Ведущее Тогда
						ЭтоВспомогательныеДанные = Истина;
					КонецЕсли;
				КонецЕсли;
				Формат = Описание.Формат; 
				ОписаниеИзмерений = ОписаниеИзмерений + ", " 
					+ Описание.Представление + " """ + ?(Формат = Неопределено, Строка(Значение), Формат(Значение, Формат)) + """";
			КонецЦикла;
			ОписаниеИзмерений = Сред(ОписаниеИзмерений, 3);
			
			Если Не ПустаяСтрока(ОписаниеИзмерений) Тогда
				Представление = Представление + " (" + ОписаниеИзмерений + ")";
			КонецЕсли;
			
		Иначе
			Представление = Строка(Данные);
			
		КонецЕсли;
		
		Строка.ПредставлениеДанных   = Представление;
		Строка.ВспомогательныеДанные = ЭтоВспомогательныеДанные;
		Строка.ТипСсылки             = ТипЗнч(Строка.Ссылка);
	КонецЦикла;
	
	Если Не ПустаяСтрока(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(МестаИспользования, АдресРезультата);
	КонецЕсли;
	
	Возврат МестаИспользования;
КонецФункции

// Поиск дублей для указанного значения.
//
// Параметры:
//     ОбластьПоиска - Строка - Имя таблицы данных (полное имя метаданных) области поиска.
//                              Например "Справочник.Номенклатура". Поддерживается поиск в справочниках, 
//                              планах видов характеристик, видах расчетов, планах счетов.
//
//     Элемент - Произвольный - объект с данными элемента, для которого производится поиск дублей
//
//     ДополнительныеПараметры - Произвольный - Параметр для передачи в обработчики событий менеджера
//
// Возвращаемое значение:
//     ТаблицаЗначений - содержит строки с описаниями дублей.
// 
Функция НайтиДублиЭлемента(Знач ОбластьПоиска, Знач ЭталонныйОбъект, Знач ДополнительныеПараметры) Экспорт
	
	ПараметрыПоискаДублей = Новый Структура;
	ПараметрыПоискаДублей.Вставить("КомпоновщикПредварительногоОтбора");
	ПараметрыПоискаДублей.Вставить("ОбластьПоискаДублей", ОбластьПоиска);
	ПараметрыПоискаДублей.Вставить("УчитыватьПрикладныеПравила", Истина);
	
	// Из параметров
	ПараметрыПоискаДублей.Вставить("ПравилаПоиска", Новый ТаблицаЗначений);
	ПараметрыПоискаДублей.ПравилаПоиска.Колонки.Добавить("Реквизит", Новый ОписаниеТипов("Строка"));
	ПараметрыПоискаДублей.ПравилаПоиска.Колонки.Добавить("Правило",  Новый ОписаниеТипов("Строка"));
	
	// См. Обработка.ПоискИУдалениеДублей
	ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора = Новый КомпоновщикНастроекКомпоновкиДанных;
	МетаОбласть = Метаданные.НайтиПоПолномуИмени(ОбластьПоиска);
	ДоступныеРеквизитыОтбора = ДоступныеИменаМетаРеквизитовОтбора(МетаОбласть.СтандартныеРеквизиты);
	ДоступныеРеквизитыОтбора = ?(ПустаяСтрока(ДоступныеРеквизитыОтбора), ",", ДоступныеРеквизитыОтбора)
		+ ДоступныеИменаМетаРеквизитовОтбора(МетаОбласть.Реквизиты);
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Запрос = "ВЫБРАТЬ " + Сред(ДоступныеРеквизитыОтбора, 2) + " ИЗ " + ОбластьПоиска;
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	
	ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора.Инициализировать( Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки) );
	
	// Вызов прикладного кода
	ОбработкаПоиска = Обработки.ПоискИУдалениеДублей.Создать();
	
	МенеджерОбластиПоиска = ОбработкаПоиска.МенеджерОбластиПоискаДублей(ОбластьПоиска);
	ИспользоватьПрикладныеПравила = ОбработкаПоиска.ЕстьПрикладныеПравилаОбластиПоискаДублей(МенеджерОбластиПоиска);
	Если ИспользоватьПрикладныеПравила Тогда
		ПрикладныеПараметры = Новый Структура;
		ПрикладныеПараметры.Вставить("ПравилаПоиска",        ПараметрыПоискаДублей.ПравилаПоиска);
		ПрикладныеПараметры.Вставить("КомпоновщикОтбора",    ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора);
		ПрикладныеПараметры.Вставить("ОграниченияСравнения", Новый Массив);
		ПрикладныеПараметры.Вставить("КоличествоЭлементовДляСравнения", 1500);
		
		МенеджерОбластиПоиска.ПараметрыПоискаДублей(ПрикладныеПараметры, ДополнительныеПараметры);
		
		ПараметрыПоискаДублей.Вставить("ДополнительныеПараметры", ДополнительныеПараметры);
	КонецЕсли;
	
	ГруппыДублей = ОбработкаПоиска.ГруппыДублей(ПараметрыПоискаДублей, ЭталонныйОбъект);
	Результат = ГруппыДублей.ТаблицаДублей;
	
	// Там ровно одна группа, возвращаем нужные элементы
	Для Каждого Строка Из Результат.НайтиСтроки(Новый Структура("Родитель", Неопределено)) Цикл
		Результат.Удалить(Строка);
	КонецЦикла;
	ПустаяСсылка = МенеджерОбластиПоиска.ПустаяСсылка();
	Для Каждого Строка Из Результат.НайтиСтроки(Новый Структура("Ссылка", ПустаяСсылка)) Цикл
		Результат.Удалить(Строка);
	КонецЦикла;
	
	Возврат Результат; 
КонецФункции

// Возвращает описание типа, включающего в себя все возможные ссылочные типы конфигурации.
//
Функция ОписаниеТипаВсеСсылки() Экспорт
	
	Возврат Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
		Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
			   Справочники.ТипВсеСсылки(),
			   Документы.ТипВсеСсылки().Типы()
			), ПланыОбмена.ТипВсеСсылки().Типы()
			), Перечисления.ТипВсеСсылки().Типы()
			), ПланыВидовХарактеристик.ТипВсеСсылки().Типы()
			), ПланыСчетов.ТипВсеСсылки().Типы()
			), ПланыВидовРасчета.ТипВсеСсылки().Типы()
			), БизнесПроцессы.ТипВсеСсылки().Типы()
			), БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы()
			), Задачи.ТипВсеСсылки().Типы()
		);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных.
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных.
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник - Массив - массив, который заполняется уникальными значениями.
//  МассивИсточник - Массив - массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений
//
//	Возвращаемое значение: 
//    Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений.
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений.
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  Структура - с полями 
//    * ИмяТаблицы - Строка
//    * Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение НСтр("ru = 'Пустой XML'");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	КоллекцияСтрок2 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	ИменаКолонок - Строка - имена колонок через запятую, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки - Строка - имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - Булево - если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах.
//
// Возвращаемое значение:
//  Булево.
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;

	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
						СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
						
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
	
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура ,   ФиксированнаяСтруктура -
//          - Соответствие, ФиксированноеСоответствие -
//          - Массив,       ФиксированныйМассив - 
//          - ХранилищеЗначения, ТаблицаЗначений -
//          - Простые типы - которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - Произвольный - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив - коллекции, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект.
//  Объект  - ОбъектXDTO  - объект, копию которого требуется создать.
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO
//
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO.
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции

// Выполняет пропорциональное распределение суммы в соответствии с заданными коэффициентами.
//
// Параметры:
//  РаспределяемаяСумма - Число;
//  КоэффициентыРаспределения - Массив;
//  ТочностьОкругления - Число.
//
// Возвращаемое значение:
//   Массив - список распределенных сумм.
//               В случае, если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), возвращается значение Неопределено.
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, КоэффициентыРаспределения, Знач Точность = 2) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(РаспределяемаяСумма, КоэффициентыРаспределения, Точность);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции

// Возвращает CLSID COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Параметры:
//  ИмяCOMСоединителя - Строка - имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Возвращаемое значение:
//  Строка - строковое представление CLSID.
//
Функция ИдентификаторCOMСоединителя(Знач ИмяCOMСоединителя) Экспорт
	
	Если ИмяCOMСоединителя = "v83.COMConnector" Тогда
	
		Возврат "181E893D-73A4-4722-B61D-D604B3D67D47";
		
	КонецЕсли;
	
	ТекстИсключения = Нстр("ru = 'На задан CLSID для класса %1'");
	ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ИмяCOMСоединителя);
	ВызватьИсключение ТекстИсключения;
	
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//    * ВариантРаботыИнформационнойБазы             - Число - Вариант работы информационной базы: 0 - файловый; 1 - клиент-серверный;
//    * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//    * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//    * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//    * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании внешнего подключения к информационной базе;
//    * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//    * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
//  СтрокаСообщенияОбОшибке - Строка - если в процессе установки внешнего соединения возникает ошибка,
//                                     то подробное описание ошибки помещается в этот параметр.
//
// Возвращаемое значение:
//  COMОбъект, Неопределенно -
//    в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//    в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  * ВариантРаботыИнформационнойБазы             - Число  -  Вариант работы информационной базы: 0 - файловый; 1 - клиент-серверный;
//	  * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//	  * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//	  * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//	  * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании внешнего подключения к информационной базе;
//	  * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//	  * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
// Возвращаемое значение:
//  Структура -
//    * Соединение                  - COMОбъект, Неопределено - указатель на COM-объект соединения или Неопределено в случае ошибки;
//    * КраткоеОписаниеОшибки       - Строка - краткое описание ошибки;
//    * ПодробноеОписаниеОшибки     - Строка - подробное описание ошибки;
//    * ОшибкаПодключенияКомпоненты - Булево - флаг ошибки подключения COM.
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь);
	
	Если ЭтоLinuxСервер() Тогда
		Результат.Соединение = Неопределено;
		Результат.ПодробноеОписаниеОшибки = НСтр("ru = 'Прямое подключение к информационной базе недоступно на сервере под управлением ОС Linux.'");
		Результат.КраткоеОписаниеОшибки = Результат.ПодробноеОписаниеОшибки;
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V83.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = ""&ИмяСервера1СПредприятия""; Ref = ""&ИмяИнформационнойБазыНаСервере1СПредприятия"";";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = ""&ИмяСервера1СПредприятия""; Ref = ""&ИмяИнформационнойБазыНаСервере1СПредприятия""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключиться к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ","
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ","
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений           = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Исключения);
	МассивПараметровДляОчистки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПараметрыДляОчистки);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("ПараметрыКлиентаНаСервере");
	Если Индекс > 0 Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры
//  СсылкаНаПредмет  - ЛюбаяСсылка - объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка.
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПредставленияПредмета");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииПредставленияПредмета(СсылкаНаПредмет, Результат);
	КонецЦикла;
	
	ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
	
	Если ПустаяСтрока(Результат) Тогда
		Если СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая() Тогда
			Результат = НСтр("ru = 'не задан'");
		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
			Результат = Строка(СсылкаНаПредмет);
		Иначе
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
			КонецЕсли;
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует соответствие для удаления объектов.
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	
	ИсключенияПоискаСсылок = Новый Соответствие;
	
	МассивИсключений = Новый Массив;
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриДобавленииИсключенийПоискаСсылок(МассивИсключений);
	КонецЦикла;
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений);
	
	МассивИсключений = ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок();
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений);
	
	МассивИсключений = Новый Массив;
	ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок(МассивИсключений);
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений);

	Возврат ИсключенияПоискаСсылок;
	
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
//   Значение - Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//   Строка - XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML - строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает XML-представление XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO  - объект, для которого требуется сформировать XML-представление.
//  Фабрика    - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XML-представление.
//                             Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   Строка - XML-представление XDTO-объекта.
//
Функция ОбъектXDTOВСтрокуXML(Знач ОбъектXDTO, Знач Фабрика = Неопределено) Экспорт
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, ОбъектXDTO, , , , НазначениеТипаXML.Явное);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Формирует XDTO-объект по XML-представлению.
//
// Параметры:
//  СтрокаXML - Строка    - XML-представление XDTO-объекта,
//  Фабрика - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XDTO-объект.
//                          Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   ОбъектXDTO.
//
Функция ОбъектXDTOИзСтрокиXML(Знач СтрокаXML, Знач Фабрика = Неопределено) Экспорт
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Чтение = Новый ЧтениеXML();
	Чтение.УстановитьСтроку(СтрокаXML);
	
	Возврат Фабрика.ПрочитатьXML(Чтение);
	
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе.
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы.
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе.
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(Знач АдресWSDL,
	Знач URIПространстваИмен,
	Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "",
	Знач ИмяПользователя,
	Знач Пароль,
	Знач Таймаут = 0,
	Знач ДелатьКонтрольныйВызов = Ложь) Экспорт

	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

// Определяет доступность объекта метаданных по функциональным опциям.
//
// Параметры:
//   ОбъектМетаданных - ОбъектМетаданных - проверяемый объект метаданных.
//
// Возвращаемое значение: 
//  Булево - Истина, если объект доступен.
//
Функция ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Экспорт
	Возврат ОбщегоНазначенияПовтИсп.ДоступностьОбъектовПоОпциям()[ОбъектМетаданных] <> Ложь;
КонецФункции

// Устанавливает или снимает пометку удаления для всех объектов, которые ссылаются на заданный "объект-владелец".
//
// Параметры:
//  Владелец        - ПланОбменаСсылка, СправочникСсылка, ДокументСсылка - ссылка на объект, который является "владельцем"
//                                                                         по отношению к помечаемым на удаление объектам.
//
//  ПометкаУдаления - Булево - признак установки/снятия пометки на удаление у всех "подчиненных" объектов.
//
Процедура УстановитьПометкуУдаленияПодчиненнымОбъектам(Знач Владелец, Знач ПометкаУдаления) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		СписокСсылок = Новый Массив;
		СписокСсылок.Добавить(Владелец);
		Ссылки = НайтиПоСсылкам(СписокСсылок);
		
		Для Каждого Ссылка из Ссылки Цикл
			
			Если ЗначениеСсылочногоТипа(Ссылка[1]) Тогда
				
				Ссылка[1].ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить.
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса.
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(НСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки 
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
//
// Возвращаемое значение: 
//  Структура - структура со свойствами:
//      * ИмяФормыПерсональныхНастроек            - Строка - имя формы для редактирования персональных настроек.
//                                                           Ранее определялись в ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек.
//      * МинимальноНеобходимаяВерсияПлатформы    - Строка - полный номер версии платформы для запуска программы. Например, "8.3.4.365".
//                                                           Ранее определялись в ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы.
//      * РаботаВПрограммеЗапрещена               - Булево - Начальное значение Ложь.
//      * ЗапрашиватьПодтверждениеПриЗавершенииПрограммы - Булево - по умолчанию Истина. Если установить Ложь, то 
//                                                                  подтверждение при завершении работы программы не будет запрашиваться, 
//                                                                  если явно не разрешить в персональных настройках программы.
//      * ОтключитьСправочникИдентификаторыОбъектовМетаданных - Булево - отключает заполнение справочника
//              ИдентификаторыОбъектовМетаданных, процедуры выгрузки и загрузки элементов справочника в узлах РИБ.
//              Для частичного встраивании отдельных функций библиотеки в конфигурации без постановки на поддержку.
//
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.3.4.365");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь); // Блокировать запуск, если версия ниже минимальной.
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	ОбщиеПараметры.Вставить("ОтключитьСправочникИдентификаторыОбъектовМетаданных", Ложь);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	// Для обратной совместимости.
	ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек(ОбщиеПараметры.ИмяФормыПерсональныхНастроек);
	ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
// Возвращаемое значение: 
//  Булево
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

// Возвращает Истина при необходимости обновления конфигурации информационной базы подчиненного узла РИБ.
// В главном узле всегда - Ложь.
//
// Возвращаемое значение: 
//  Булево
//
Функция ТребуетсяОбновлениеКонфигурацииПодчиненногоУзлаРИБ() Экспорт
	
	Возврат ЭтоПодчиненныйУзелРИБ() И КонфигурацияИзменена();
	
КонецФункции

// Возвращает Истина, если текущий сеанс выполняется на сервере, работающим под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - Истина, если сервер работает под управлением ОС Linux.
//
Функция ЭтоLinuxСервер() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

// Предназначена для вставки в начало обработчика ПриСозданииНаСервере управляемых форм, которые размещаются на рабочем столе.
//
// Предотвращает открытие формы в ряде особых случаев:
//  - если рабочий стол открывается до завершения обновления данных ИБ
//   (исключается возможность заведомо ошибочного обращения к еще необновленным данным);
//  - если в разделенную ИБ выполняется вход в сеансе с неустановленным значением разделителя ОбластьДанныхОсновныеДанные
//   (исключается возможность заведомо ошибочного обращения к разделенным данным из неразделенного сеанса);
//
// Не следует использовать в формах, которые используются перед началом работы системы,
// а также в формах, предназначенных для работы в неразделенном сеансе.
//
// Параметры:
//  Форма - УправляемаяФорма - ссылка на форму, которая создается.
//  Отказ - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//  СтандартнаяОбработка - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//
// Возвращаемое значение:
//  Булево - если Ложь, значит установлен отказ создания формы.
//
Функция ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	Если Форма.Параметры.Свойство("АвтоТест") Тогда
		// Возврат при получении формы для анализа.
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Если ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("СкрытьРабочийСтолПриНачалеРаботыСистемы") <> Неопределено Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Истина;
	
КонецФункции

// Выполняет действия перед продолжением выполнения обработчика регламентного задания.
//
// Например, проверяет возможность выполнения обработчика регламентного задания.
// Если администратор не заблокировал выполнение регламентных заданий до
// окончания обновления ИБ, тогда требуется прекратить выполнение обработчика.
// 
Процедура ПриНачалеВыполненияРегламентногоЗадания() Экспорт
	
	Если СтандартныеПодсистемыСервер.НеобходимоОбновлениеПараметровРаботыПрограммы() Тогда
		ВызватьИсключение
			НСтр("ru = 'Вход в программу временно невозможен в связи с обновлением на новую версию.
			           |Рекомендуется запрещать выполнение регламентных заданий на время обновления.'");
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено()
	   И ПланыОбмена.ГлавныйУзел() = Неопределено
	   И ЗначениеЗаполнено(Константы.ГлавныйУзел.Получить()) Тогда
		
		ВызватьИсключение
			НСтр("ru = 'Вход в программу временно невозможен до восстановления связи с главным узлом.
			           |Рекомендуется запрещать выполнение регламентных заданий на время восстановления.'");
	КонецЕсли;
	
КонецПроцедуры

// Возвращает редакцию конфигурации.
// Редакцией принято называть две первые группы цифр полной версии конфигурации.
// Например, у версии "1.2.3.4" редакция "1.2".
//
// Возвращаемое значение:
//  Строка - номер редакции конфигурации.
//
Функция РедакцияКонфигурации() Экспорт
	
	Результат = "";
	ВерсияКонфигурации = Метаданные.Версия;
	
	Позиция = Найти(ВерсияКонфигурации, ".");
	Если Позиция > 0 Тогда
		Результат = Лев(ВерсияКонфигурации, Позиция);
		ВерсияКонфигурации = Сред(ВерсияКонфигурации, Позиция + 1);
		Позиция = Найти(ВерсияКонфигурации, ".");
		Если Позиция > 0 Тогда
			Результат = Результат + Лев(ВерсияКонфигурации, Позиция - 1);
		Иначе
			Результат = "";
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(Результат) Тогда
		Результат = Метаданные.Версия;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами.

// Процедура предназначена для заполнения реквизита формы типа ДанныеФормыДерево.
//
// Параметры:
//  КоллекцияЭлементовДерева - ДанныеФормыДерево - реквизит, который нужно заполнить.
//  ДеревоЗначений           - ДеревоЗначений    - данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры
//  Комментарий  - Строка - текст комментария.
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт

	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
//   Отбор - Структура - содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором:
//						Ключ - Строка - имя свойства элемента метаданных;
//						Значение - Массив - множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//   ДеревоЗначений - дерево описания метаданных конфигурации.
//
Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               НСтр("ru = 'Константы'"),                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             НСтр("ru = 'Справочники'"),               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               НСтр("ru = 'Документы'"),                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", НСтр("ru = 'Планы видов характеристик'"), БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             НСтр("ru = 'Планы счетов'"),              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       НСтр("ru = 'Планы видов характеристик'"), БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        НСтр("ru = 'Регистры сведений'"),         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      НСтр("ru = 'Регистры накопления'"),       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     НСтр("ru = 'Регистры бухгалтерии'"),      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         НСтр("ru = 'Регистры расчета'"),          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          НСтр("ru = 'Бизнес-процессы'"),           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  НСтр("ru = 'Задачи'"),                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка - представление информационной базы.
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на элемент базы данных, для которого требуется получить результат функции;
//  Тип    - Тип - тип значения реквизита.
// 
// Возвращаемое значение:
//  Строка - строка реквизитов объекта метаданных конфигурации, разделенные символом ",".
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных.
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип.
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных.
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ  = ЧастиИмени[1];
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Если ЧастиИмени.Количество() = 2 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОм = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Попытка
			Возврат Менеджер[ИмяОМ];
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//  Булево.
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает имя вида объектов метаданных по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, вид которого требуется получить.
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Возвращает имя вида объектов метаданных по типу объекта.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип - Тип - Тип прикладного объекта, определенный в конфигурации .
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Примеры:
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная".
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, для которого необходимо получить имя таблицы ИБ.
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного объекта.
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение - Произвольный - проверяемое значение.
//
// Возвращаемое значение:
//  Булево - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Возврат ЭтоСсылка(ТипЗнч(Значение));
	
КонецФункции

// Проверка того, что переданный тип является ссылочным типом данных.
// Для типа "Неопределено" возвращается Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Тип <> Тип("Неопределено") 
		И (Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип));
	
КонецФункции

// Проверяет, является ли объект группой элементов.
//
// Параметры:
//  Объект - ЛюбаяСсылка, Объект - проверяемый объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ЭтоГруппа") = Истина;
	
КонецФункции

// Возвращает ссылку, соответствующую объекту метаданных, для
// использования в базе данных.
//  Например:
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ТипЗнч(Ссылка));
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.Организации");
//
//  Поддерживаемые объекты метаданных:
// - Подсистемы (требуется программировать переименование)
// - Роли       (требуется программировать переименование)
// - ПланыОбмена
// - Константы
// - Справочники
// - Документы
// - ЖурналыДокументов
// - Отчеты
// - Обработки
// - ПланыВидовХарактеристик
// - ПланыСчетов
// - ПланыВидовРасчета
// - РегистрыСведений
// - РегистрыНакопления
// - РегистрыБухгалтерии
// - РегистрыРасчета
// - БизнесПроцессы
// - Задачи
// 
// Подробнее см. в функции СвойстваКоллекцийОбъектовМетаданных()
// модуля менеджера справочника ИдентификаторыОбъектовМетаданных.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных - объект метаданных конфигурации;
//                            - Тип - тип, который можно успешно использовать в функции Метаданные.НайтиПоТипу();
//                            - Строка - полное имя объекта метаданных, которое можно успешно использовать
//                              в функции Метаданные.НайтиПоПолномуИмени().
// Возвращаемое значение:
//  СправочникСсылка.ИдентификаторыОбъектовМетаданных.
//
Функция ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	ТипОписанияОбъектаМетаданных = ТипЗнч(ОписаниеОбъектаМетаданных);
	Если ТипОписанияОбъектаМетаданных = Тип("Тип") Тогда
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ОписаниеОбъектаМетаданных);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Объект метаданных не найден по типу:
				           |""%1"".'"),
				ОписаниеОбъектаМетаданных);
		Иначе
			ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		КонецЕсли;
		
	ИначеЕсли ТипОписанияОбъектаМетаданных = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОписаниеОбъектаМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОписаниеОбъектаМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Возврат СтандартныеПодсистемыПовтИсп.ИдентификаторОбъектаМетаданных(ПолноеИмяОбъектаМетаданных);
	
КонецФункции

// Возвращает объект метаданных по переданному идентификатору.
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовМетаданных - идентификатор объекта метаданных.
//
// Возвращаемое значение:
//  ОбъектМетаданных.
//
Функция ОбъектМетаданныхПоИдентификатору(Идентификатор) Экспорт
	
	СтандартныеПодсистемыПовтИсп.СправочникИдентификаторыОбъектовМетаданныхПроверкаИспользования(Истина);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Идентификатор);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Идентификаторы.Ссылка КАК Ссылка,
	|	Идентификаторы.КлючОбъектаМетаданных,
	|	Идентификаторы.ПолноеИмя,
	|	Идентификаторы.ПометкаУдаления
	|ИЗ
	|	Справочник.ИдентификаторыОбъектовМетаданных КАК Идентификаторы
	|ГДЕ
	|	Идентификаторы.Ссылка = &Ссылка";
	
	Выгрузка = Запрос.Выполнить().Выгрузить();
	
	Если Выгрузка.Количество() = 0 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
			           |
			           |Идентификатор ""%1""
			           |не найден в справочнике ""Идентификаторы объектов метаданных"".'")
			+ СтандартныеПодсистемыСервер.УточнениеОшибкиПараметровРаботыПрограммыДляРазработчика(),
			Строка(Идентификатор));
	КонецЕсли;
	
	// Проверка соответствия ключа объекта метаданных полному имени объекта метаданных
	РезультатПроверки = Справочники.ИдентификаторыОбъектовМетаданных.КлючОбъектаМетаданныхСоответствуетПолномуИмени(Выгрузка[0]);
	Если РезультатПроверки.НеСоответствует Тогда
		Если РезультатПроверки.ОбъектМетаданных = Неопределено Тогда
			Если РезультатПроверки.КлючОбъектаМетаданных = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
					           |
					           |Идентификатору ""%1""
					           |найденому в справочнике ""Идентификаторы объектов метаданных"",
					           |соответствует несуществующий объект метаданных
					           |""%2"".'")
					+ СтандартныеПодсистемыСервер.УточнениеОшибкиПараметровРаботыПрограммыДляРазработчика(),
					Строка(Идентификатор),
					Выгрузка[0].ПолноеИмя);
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
					           |
					           |Идентификатору ""%1""
					           |найденому в справочнике ""Идентификаторы объектов метаданных"",
					           |соответствует удаленный объект метаданных.'")
					+ СтандартныеПодсистемыСервер.УточнениеОшибкиПараметровРаботыПрограммыДляРазработчика(),
					Строка(Идентификатор));
			КонецЕсли;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ИдентификаторОбъектаМетаданных().
				           |
				           |Идентификатору ""%1""
				           |найденому в справочнике ""Идентификаторы объектов метаданных"",
				           |соответствует объект метаданных ""%2"",
				           |полное имя которого отличается от заданного в идентификаторе.'")
				+ СтандартныеПодсистемыСервер.УточнениеОшибкиПараметровРаботыПрограммыДляРазработчика(),
				Строка(Идентификатор),
				РезультатПроверки.ОбъектМетаданных.ПолноеИмя());
		КонецЕсли;
	КонецЕсли;
	
	Если Выгрузка[0].ПометкаУдаления Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при выполнении функции ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору().
			           |
			           |Идентификатор ""%1""
			           |найден в справочнике ""Идентификаторы объектов метаданных"",
			           |но значение реквизита ""Пометка удаления"" установлено Истина.'")
			+ СтандартныеПодсистемыСервер.УточнениеОшибкиПараметровРаботыПрограммыДляРазработчика(),
			Строка(Идентификатор));
	КонецЕсли;
	
	Возврат РезультатПроверки.ОбъектМетаданных;
	
КонецФункции

// Для использования в процедуре ПриДобавленииПереименованийОбъектовМетаданных
// общего модуля ОбщегоНазначенияПереопределяемый для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - Структура - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка    - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка    - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка    - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка    - внутренний идентификатор библиотеки, к которой относится ВерсияИБ.
//                                         Для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	СтандартныеПодсистемыПовтИсп.СправочникИдентификаторыОбъектовМетаданныхПроверкаИспользования();
	
	СтароеИмяКоллекции = ВРег(ИмяКоллекции(СтароеПолноеИмя));
	НовоеИмяКоллекции  = ВРег(ИмяКоллекции(НовоеПолноеИмя));
	
	ЗаголовокОшибки =
		НСтр("ru = 'Ошибка в процедуре ПриДобавленииПереименованийОбъектовМетаданных общего модуля ОбщегоНазначенияПереопределяемый.'");
	
	Если СтароеИмяКоллекции <> НовоеИмяКоллекции Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Не совпадают имена типов переименованного объекта метаданных.
			             |Прежний тип: ""%1"",
			             |новый тип: ""%2"".'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя);
	КонецЕсли;
	
	Если Итог.КоллекцииБезКлюча[СтароеИмяКоллекции] = Неопределено Тогда
		
		СписокДопустимыхТипов = "";
		Для каждого КлючИЗначение Из Итог.КоллекцииБезКлюча Цикл
			СписокДопустимыхТипов = СписокДопустимыхТипов + КлючИЗначение.Значение + "," + Символы.ПС;
		КонецЦикла;
		СписокДопустимыхТипов = СокрП(СписокДопустимыхТипов);
		СписокДопустимыхТипов = ?(ЗначениеЗаполнено(СписокДопустимыхТипов),
			Лев(СписокДопустимыхТипов, СтрДлина(СписокДопустимыхТипов) - 1), "");
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Для типа объекта метаданных ""%1"" не требуется описывать переименование,
			             |так как сведения об объектах метаданных этого типа обновляются автоматически.
			             |
			             |Описывать переименования требуется только для следующих типов:
			             |%2.'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя,
			СписокДопустимыхТипов);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИдентификаторБиблиотеки) Тогда
		Библиотека = ВРег(ИдентификаторБиблиотеки) <> ВРег(Метаданные.Имя);
	Иначе
		ИдентификаторБиблиотеки = Метаданные.Имя;
		Библиотека = Ложь;
	КонецЕсли;
	
	ПорядокБиблиотеки = Итог.ПорядокБиблиотек[ИдентификаторБиблиотеки];
	Если ПорядокБиблиотеки = Неопределено Тогда
		ПорядокБиблиотеки = Итог.ПорядокБиблиотек.Количество();
		Итог.ПорядокБиблиотек.Вставить(ИдентификаторБиблиотеки, ПорядокБиблиотеки);
	КонецЕсли;
	
	ВерсияБиблиотеки = Итог.ВерсииБиблиотек[ИдентификаторБиблиотеки];
	Если ВерсияБиблиотеки = Неопределено Тогда
		ВерсияБиблиотеки = ОбновлениеИнформационнойБазыСлужебный.ВерсияИБ(ИдентификаторБиблиотеки);
		Итог.ВерсииБиблиотек.Вставить(ИдентификаторБиблиотеки, ВерсияБиблиотеки);
	КонецЕсли;
	
	Если ВерсияБиблиотеки = "0.0.0.0" Тогда
		// При начальном заполнении переименования не требуются.
		Возврат;
	КонецЕсли;
	
	Результат = ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияИБ, ВерсияБиблиотеки);
	Если Результат > 0 Тогда
		ЧастиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВерсияИБ, ".");
		
		ОписаниеПереименования = Итог.Таблица.Добавить();
		ОписаниеПереименования.ПорядокБиблиотеки = ПорядокБиблиотеки;
		ОписаниеПереименования.ВерсияЧасть1      = Число(ЧастиВерсии[0]);
		ОписаниеПереименования.ВерсияЧасть2      = Число(ЧастиВерсии[1]);
		ОписаниеПереименования.ВерсияЧасть3      = Число(ЧастиВерсии[2]);
		ОписаниеПереименования.ВерсияЧасть4      = Число(ЧастиВерсии[3]);
		ОписаниеПереименования.СтароеПолноеИмя   = СтароеПолноеИмя;
		ОписаниеПереименования.НовоеПолноеИмя    = НовоеПолноеИмя;
		ОписаниеПереименования.ПорядокДобавления = Итог.Таблица.Индекс(ОписаниеПереименования);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
// Возвращаемое значение:
//  Строка.
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Параметры:
//   ОписаниеТипа - ОписаниеТипов - проверяемая коллекция типов;
//   ТипЗначения  - Тип - проверяемый тип.
//
// Возвращаемое значение:
//   Булево      - Истина, если совпадает.
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие табличной части у справочника.
//
// Параметры:
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
// Возвращаемое значение:
//  Булево - Истина, если табличная часть есть.
//
// Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Формирует расширенное представление объекта.
// Расширенное представление объекта складывается из представления объекта, кода и наименования.
// Если для объекта не удалось получить расширенное представление, то возвращается стандартное 
// представление объекта, формируемое платформой.
//
// Пример возвращаемого значения функции:
// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
//
// Параметры:
//  Объект - СправочникСсылка,
//           ПланСчетовСсылка,
//           ПланОбменаСсылка,
//           ПланВидовХарактеристикСсылка,
//           ПланВидовРасчетаСсылка -  Объект, для которого требуется получить расширенное представление.
//
// Возвращаемое значение:
//  Строка - расширенное представление объекта.
//
Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
	
	ОбъектМетаданных = Объект.Метаданные();
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
		Тогда
		
		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
			
			ЗначенияРеквизитов = ЗначенияРеквизитовОбъекта(Объект, "Код, Наименование");
			
			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта);
			
			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
			
		Иначе
			
			Результат = Строка(Объект);
			
		КонецЕсли;
		
	Иначе
		
		Результат = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов.
//
// Параметры:
//  СтандартныеРеквизиты - ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
//  ИмяРеквизита         - Строка - реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
// 
// Возвращаемое значение:
//   Булево - Истина, если реквизит входит в подмножество стандартных реквизитов.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного.
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора).
//
// Параметры:
//  ОбъектМетаданных  - ОбъектМетаданных - объект, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленные через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - описание требуемых свойств всех реквизитов объекта метаданных.
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита.
//
// Параметры:
//  ЭлементСостава            - ОбъектМетаданных - элемент состава общего реквизита, использование которого требуется проверить.
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - объект метаданных общего реквизита, которому принадлежит ЭлементСостава.
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь.
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
//  ОбъектМетаданных - Строка, ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю повторного использования.
//  Разделитель      - Строка - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
//  Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

// Возвращает имя предопределенного элемента по указанной ссылке.
// Для использования вместо устаревшего метода ПолучитьИмяПредопределенного в
// конфигурациях, рассчитанных на платформу версии 8.2.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на предопределенный элемент.
//
// Возвращаемое значение:
//  Строка - имя предопределенного элемента.
//
Функция ИмяПредопределенного(Знач Ссылка) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ИмяПредопределенныхДанных");
	
КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Конструктор объекта ОписаниеТипов, содержащего тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Конструктор объекта ОписаниеТипов, содержащего тип Дата.
//
// Параметры:
//  ЧастиДаты - ЧастиДаты - набор вариантов использования значений типа Дата.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаДата(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции

// Позволяет определить, есть ли среди реквизитов объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита;
//  МетаданныеОбъекта - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта) Экспорт

	Возврат НЕ (МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Документы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Перечисления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Задачи.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Константы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПоследовательность(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Последовательности.Содержит(ОбъектМетаданных);
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегламентноеЗадание(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных);
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
		
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	Позиция = Найти(ИмяОбъектаМетаданных, ".");
	Если Позиция > 0 Тогда 
		ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
		Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Отчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Обработки".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Сохраняет настройку в хранилище общих настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Необязательный. Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Необязательный. Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Необязательный. Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, в котором сохраняется настройка.
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого загружается настройка.
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Необязательный. Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек), ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	Иначе
		УстановитьПривилегированныйРежим(Истина);
		Если УдалитьБитыеСсылки(Результат) Тогда
			Результат = ЗначениеПоУмолчанию;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Удаляет битые ссылки из переменной.
//
// Параметры:
//   СсылкаИлиКоллекция - ЛюбаяСсылка, Произвольный - Проверяемый объект или очищаемая коллекция.
//
// Возвращаемое значение: 
//   Булево - 
//       * Истина - СсылкаИлиКоллекция ссылочного типа и объект не найден в базе данных.
//       * Ложь - Когда СсылкаИлиКоллекция не ссылочного типа или объект найден в базе данных.
//
Функция УдалитьБитыеСсылки(СсылкаИлиКоллекция)
	
	Тип = ТипЗнч(СсылкаИлиКоллекция);
	
	Если Тип = Тип("Неопределено")
		Или Тип = Тип("Булево")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Число")
		Или Тип = Тип("Дата") Тогда // Оптимизация - часто используемые примитивные типы.
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Массив") Тогда
		
		Количество = СсылкаИлиКоллекция.Количество();
		Для Номер = 1 По Количество Цикл
			ОбратныйИндекс = Количество - Номер;
			Значение = СсылкаИлиКоллекция[ОбратныйИндекс];
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Удалить(ОбратныйИндекс);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Структура")
		Или Тип = Тип("Соответствие") Тогда
		
		Для Каждого КлючИЗначение Из СсылкаИлиКоллекция Цикл
			Значение = КлючИЗначение.Значение;
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Вставить(КлючИЗначение.Ключ, Неопределено);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли ЭтоСсылка(Тип) Тогда
		
		Если ЗначениеРеквизитаОбъекта(СсылкаИлиКоллекция, "Ссылка") = Неопределено Тогда
			СсылкаИлиКоллекция = Неопределено;
			Возврат Истина; // "Битая" ссылка.
		Иначе
			Возврат Ложь; // Объект найден.
		КонецЕсли;
		
	Иначе
		
		Возврат Ложь; // Не ссылка.
		
	КонецЕсли;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого удаляется настройка.
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с настройкой рабочей даты

// Сохраняет настройку рабочей даты пользователя.
//
// Параметры:
//	НоваяРабочаяДата - Дата - Дата, которую необходимо установить в качестве рабочей даты пользователя.
//	ИмяПользователя - Строка - Имя пользователя, для которого устанавливается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//			
Процедура УстановитьРабочуюДатуПользователя(НоваяРабочаяДата, ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, , НоваяРабочаяДата, , ИмяПользователя);

КонецПроцедуры

// Возвращает значение настройки рабочей даты для пользователя.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или пустая дата, если настройка не задана.
//
Функция РабочаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");

	Результат = ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, , '0001-01-01', , ИмяПользователя);
	
	Если ТипЗнч(Результат) <> Тип("Дата") Тогда
		Результат = '0001-01-01';
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение настройки рабочей даты для пользователя или текущей даты сеанса,
// если рабочая дата пользователя не задана.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или текущая дата сеанса, если настройка не задана.
//
Функция ТекущаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	Результат = РабочаяДатаПользователя(ИмяПользователя);
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		Результат = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Возврат НачалоДня(Результат);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры
//  ТабДокумент        - ТабличныйДокумент - табличный документ.
//  ВыводимыеОбласти   - Массив, ТабличныйДокумент - массив из проверяемых таблиц или табличный документ. 
//  РезультатПриОшибке - Булево - какой возвращать результат при возникновении ошибки.
//
// Возвращаемое значение:
//   Булево   - умещаются или нет переданные документы.
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
//   ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
//          пользовательских сеансов со значением разделителя равным текущему.
//          В случае обнаружения других сеансов будет выдано исключение.
//          Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.РазблокироватьТекущуюОбластьДанных();
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
//   Использование - Булево - Использование разделителя ОбластьДанных в сеансе
//   ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
//   Тип значения разделителя - значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
//   Булево - Истина, если разделение используется.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	ИспользованиеРазделителя = Неопределено;
	ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	Возврат ИспользованиеРазделителя;
	
КонецФункции

// Процедура инициализации разделенной информационной базы.
// 
// Параметры:
//   ВключитьРазделение - Булево - признак включения разделения в информационной базе.
//
Процедура УстановитьПараметрыРазделенияИнформационнойБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка, УдалениеОбъекта - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсов;
//  Пользователь - Строка - имя пользователя;
//  Пароль - Строка - пароль пользователя;
//  Интерфейс - Строка - имя интерфейса.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
//   ВнешнееСоединение - COMОбъект - объект COM-соединение, которое используется для работы с корреспондентом.
//   ИмяИнтерфейса - Строка -.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = НСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'");
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение версий интерфейса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ПодстрокаПоиска = СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов);

		ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТаблицаКэша.Идентификатор КАК Идентификатор,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор ПОДОБНО ""%" + ПодстрокаПоиска + "%""
			|		СПЕЦСИМВОЛ ""~""";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			
			Запись.Удалить();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для обработки событий и вызова необязательных подсистем.

// Возвращает Истина, если "функциональная" подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
//
// У "функциональной" подсистемы снят флажок "Включать в командный интерфейс".
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
	ИменаПодсистем = СтандартныеПодсистемыПовтИсп.ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Получение обработчиков серверных событий.

// Возвращает структуру для добавления обязательного события.
//
// Возвращаемое значение:
//  Структура - 
//    * ИмяСобытия - Строка - представление события.
//       Пример: "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
//    * Обязательное - Булево, если Истина, то для данного события обязательно объявление обработчиков.
//
Функция НовоеСобытие() Экспорт
	
	Возврат Новый Структура("Имя, Обязательное", "", Ложь);

КонецФункции

// Возвращает обработчики указанного серверного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
// Возвращаемое значение:
//  ФиксированныйМассив - со значениями типа ФиксированнаяСтруктура со свойствами:
//    * Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//    * Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСобытия(Событие) Экспорт
	
	Возврат СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Ложь);
	
КонецФункции

// Возвращает обработчики указанного серверного служебного события.
//
// Параметры:
//  Событие  - Строка - например,
//             "СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПоддерживаемыхВерсийПрограммныхИнтерфейсов".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа ФиксированнаяСтруктура со свойствами:
//    * Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//    * Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСлужебногоСобытия(Событие) Экспорт
	
	Возврат СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Истина);
	
КонецФункции

// Обновляет данные в кэше версий.
//
// Параметры:
//  Идентификатор      - Строка - идентификатор записи кэша.
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
		|	ТаблицаКэша.Данные КАК Данные,
		|	ТаблицаКэша.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
		|ГДЕ
		|	ТаблицаКэша.Идентификатор = &Идентификатор
		|	И ТаблицаКэша.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	ОшибкаУстановкиБлокировки = Ложь;
	
	Попытка
		
		СтруктураКлюча = Новый Структура("Идентификатор, ТипДанных", Идентификатор, ТипДанных);
		Ключ = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьКлючЗаписи(СтруктураКлюча);
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			// Данные уже обновляются из другого сеанса
			ОшибкаУстановкиБлокировки = Истина;
			ВызватьИсключение;
		КонецПопытки;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Убедимся что данные требуют обновления
		Если НЕ Результат.Пустой() Тогда
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если НЕ ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				// Данные актуальны
				ОтменитьТранзакцию();
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Набор = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьНаборЗаписей();
		
		Набор.Отбор.Идентификатор.Установить(Идентификатор);
		Набор.Отбор.ТипДанных.Установить(ТипДанных);
		
		Запись = Набор.Добавить();
		Запись.Идентификатор = Идентификатор;
		Запись.ТипДанных = ТипДанных;
		Запись.ДатаОбновления = ТекущаяУниверсальнаяДата();
		
		Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Или Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
			Данные = ПодготовитьДанныеКэшаВерсий(ТипДанных, ПараметрыПолучения);
			Запись.Данные = Новый ХранилищеЗначения(Данные);
			
		Иначе
			
			Набор.ДополнительныеСвойства.Вставить("ПараметрыПолучения", ПараметрыПолучения);
			
		КонецЕсли;
		
		Набор.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		Если ОшибкаУстановкиБлокировки Тогда
			Возврат;
		Иначе
			ВызватьИсключение;
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Подготавливает данные для кэша программных интерфейсов.
//
// Параметры:
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Функция ПодготовитьДанныеКэшаВерсий(Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
		Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
	ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2], ПараметрыПолучения[3]);
	Иначе
		ШаблонТекста = НСтр("ru = 'Неизвестный тип данных кэша версий: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает факт устаревания записи кэша версий.
//
// Параметры:
//  Запись - РегистрСведенийМенеджерЗаписи.КэшПрограммныхИнтерфейсов - запись, факт устаревания которой требуется проверить.
//
// Возвращаемое значение:
//  Булево - признак устаревания записи
//
Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

// Формирует идентификатор записи кэша версий из адреса сервера и имени ресурса.
//
// Параметры:
//  Адрес - Строка - адрес сервера
//  Имя   - Строка - имя ресурса
//
// Возвращаемое значение:
//  Строка - идентификатор записи кэша версий 
//
Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя) Экспорт
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
// Параметры:
//  АдресWSDL       - Строка - месторасположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль          - Строка - пароль пользователя
//  Таймаут         - Число  - таймаут на получение wsdl
//
// Возвращаемое значение:
//  WSОпределения 
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	Если Не ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		Возврат Новый WSОпределения(АдресWSDL, ИмяПользователя, Пароль, ,Таймаут);
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(АдресWSDL);
	ПараметрыПолучения.Добавить(ИмяПользователя);
	ПараметрыПолучения.Добавить(Пароль);
	ПараметрыПолучения.Добавить(Таймаут);
	
	ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
		АдресWSDL, 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Ложь);
		
	ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
	
	ДанныеWSDL.Записать(ИмяФайлаWSDL);
	
	Определения = Новый WSОпределения(ИмяФайлаWSDL);
	
	Попытка
		УдалитьФайлы(ИмяФайлаWSDL);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат Определения;
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL           - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса          - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя     - Строка - имя пользователя для входа на сервер
//  Пароль              - Строка - пароль пользователя
//  Таймаут             - Число  - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль,
	Знач Таймаут = 0) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(АдресWSDL);
	КонецЕсли;
	
	Прокси = Новый WSПрокси(WSОпределения, URIПространстваИмен, ИмяСервиса, ИмяТочкиПодключения, ИнтернетПрокси, Таймаут);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль       = Пароль;
	
	Возврат Прокси;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Устаревшие процедуры и функции

// Устарела. Следует использовать ПриСозданииНаСервере.
Функция ПриСозданииФормыНаСервере(Форма, СтандартнаяОбработка, Отказ) Экспорт
	
	Возврат Не ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка);
	
КонецФункции

// Устарела. Следует использовать ЗначенияРеквизитовОбъекта.
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

	Возврат ЗначенияРеквизитовОбъекта(Ссылка, ИменаРеквизитов);
	
КонецФункции

// Устарела. Следует использовать ЗначениеРеквизитаОбъекта.
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	
КонецФункции 

// Устарела. Следует использовать ЕстьСсылкиНаОбъект.
Функция ОбъектИспользуютсяВБазеДанных(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	Возврат ЕстьСсылкиНаОбъект(СсылкаИлиМассивСсылок, ИскатьСредиСлужебныхОбъектов);
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку.
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Структура, Разделитель);
	
КонецФункции

// Устарела. Следует использовать РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации().
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			ВыполненаУстановкаРазделенияСеанса = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Попытка
		
		РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации(ИмяЭкспортнойПроцедуры, Параметры);
		
		Если ВыполненаУстановкаРазделенияСеанса Тогда
			УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
	Исключение
		
		Если ВыполненаУстановкаРазделенияСеанса Тогда
			УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Устарела. Следует использовать РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации().
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	Попытка
		РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации(ИмяЭкспортнойПроцедуры);
		Возврат Истина;
	Исключение
		ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль, Знач Таймаут)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", Таймаут);
	
	ОписаниеФайла = Неопределено;
	
	ПриСкачиванииФайлаНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	// Попробуем создать WS определения на основе полученного файла
	Определения = Новый WSОпределения(ОписаниеФайла.Путь);
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	Попытка
		УдалитьФайлы(ОписаниеФайла.Путь);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ДанныеФайла;
	
КонецФункции

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = Найти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

Процедура ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений)
	Для Каждого ЭлементМассива Из МассивИсключений Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
			ЭлементМетаданные = Метаданные.НайтиПоПолномуИмени(ЭлементМассива);
		Иначе
			ЭлементМетаданные = ЭлементМассива;
		КонецЕсли;
		
		РодительМетаданные = ЭлементМетаданные.Родитель();
		
		// Регистрация исключаемого объекта метаданных целиком (всех ссылок, которые он может содержать).
		Если ТипЗнч(РодительМетаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
			ИсключенияПоискаСсылок.Вставить(ЭлементМетаданные, "*");
			Продолжить;
		КонецЕсли;
		
		// Регистрация исключаемого реквизита объекта метаданных.
		ОтносительныйПутьКРеквизиту = ЭлементМетаданные.Имя;
		РодительРодителя = РодительМетаданные.Родитель();
		Пока ТипЗнч(РодительРодителя) <> Тип("ОбъектМетаданныхКонфигурация") Цикл
			ОтносительныйПутьКРеквизиту = РодительМетаданные.Имя + "." + ОтносительныйПутьКРеквизиту;
			РодительМетаданные = РодительРодителя;
			РодительРодителя   = РодительМетаданные.Родитель();
		КонецЦикла;
		
		ПутиКРеквизитам = ИсключенияПоискаСсылок.Получить(РодительМетаданные);
		Если ПутиКРеквизитам = Неопределено Тогда
			ПутиКРеквизитам = Новый Массив;
		ИначеЕсли ПутиКРеквизитам = "*" Тогда
			Продолжить; // - Пропуск, если весь объект метаданных уже исключен.
		КонецЕсли;
		ПутиКРеквизитам.Добавить(ОтносительныйПутьКРеквизиту);
		
		ИсключенияПоискаСсылок.Вставить(РодительМетаданные, ПутиКРеквизитам);
	КонецЦикла;
КонецПроцедуры

// Возвращает строку ключа настроек, не превышающую допустимую длину.
// Проверяет длину строки на входе и, в случае превышения 128, преобразует ее конец по алгоритму MD5 в короткий
// вариант, в результате чего строка становится длиной 128 символов.
// Если исходная строка менее 128 символов, она возвращается в неизменном виде.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
Функция КлючНастроек(Знач Строка)
	Результат = Строка;
	Если СтрДлина(Строка) > 128 Тогда // ключ более 128 символов вызовет исключение при обращении к хранилищу настроек
		Результат = Лев(Строка, 96);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, 97));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег(ИмяТипаКонстанты()) Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыСведений()) Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыНакопления()) Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыБухгалтерии()) Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыРасчета()) Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаСправочники()) Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаДокументы()) Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОтчеты()) Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОбработки()) Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаБизнесПроцессы()) Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЖурналыДокументов()) Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЗадачи()) Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыСчетов()) Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыОбмена()) Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовХарактеристик()) Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовРасчета()) Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	
	Возврат Модуль;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы

// Получить файл из Интернета по протоколу http(s), либо ftp и сохранить его во временный файл.
//
// Параметры:
//   URL                  - Строка - url файла в формате
//                                   [Протокол://]<Сервер>/<Путь к файлу на сервере>
//   ПараметрыПолучения   - Структура со свойствами
//     ПутьДляСохранения    - Строка - путь на сервере (включая имя файла), для сохранения скачанного файла
//     Пользователь         - Строка - пользователь от имени которого установлено соединение
//     Пароль               - Строка - пароль пользователя от которого установлено соединение
//     Порт                 - Число  - порт сервера с которым установлено соединение
//     ЗащищенноеСоединение - Булево - для случая http загрузки флаг указывает,
//                                     что соединение должно производиться через https
//     ПассивноеСоединение  - Булево - для случая ftp загрузки флаг указывает,
//                                     что соединение должно пассивным (или активным)
//   ВозвращаемоеЗначение - (выходной параметр)
//     Структура, со свойствами
//       Статус - Булево - ключ присутствует в структуре всегда, значения
//                         Истина - вызов функции успешно завершен
//                         Ложь   - вызов функции завершен неудачно
//       Путь   - Строка - путь к файлу на сервере, ключ используется только
//                         если статус Истина
//       СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь
//
Процедура ПриСкачиванииФайлаНаСервере(Знач Адрес, Знач ПараметрыПолучения, ВозвращаемоеЗначение)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернета = ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ВозвращаемоеЗначение = МодульПолучениеФайловИзИнтернета.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = МодульРаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ Замена ссылок

Функция ОписаниеТипаКлючиЗаписей()
	
	ДобавляемыеТипы = Новый Массив;
	Для Каждого Мета Из Метаданные.РегистрыСведений Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрСведенийКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыНакопления Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрНакопленияКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыБухгалтерии Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрБухгалтерииКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыРасчета Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрРасчетаКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	
	Возврат Новый ОписаниеТипов(ДобавляемыеТипы); 
КонецФункции

Процедура РазметитьМестаИспользования(Знач Конфигурация, Знач Ссылка, Знач ЦелеваяСсылка, Знач ТаблицаПоиска, РезультатРазметки = Неопределено)
	УстановитьПривилегированныйРежим(Истина);

	ТипКлючЗаписи  = Конфигурация.ТипКлючЗаписи;
	МетаКонстанты  = Конфигурация.МетаКонстанты;
	ТипВсеСсылки   = Конфигурация.ТипВсеСсылки;
	ТипКлючЗаписей = Конфигурация.ТипКлючЗаписи;
	
	// Устанавливаем порядок известных и проверяем наличие неопознанных объектов
	ФильтрСсылки = Новый Структура("Ссылка, КлючЗамены", Ссылка, "");
	
	РезультатРазметки = Новый Структура;
	РезультатРазметки.Вставить("МестаИспользования", ТаблицаПоиска.НайтиСтроки(ФильтрСсылки) );
	РезультатРазметки.Вставить("ОшибкиРазметки",     Новый Массив);
	
	Для Каждого МестоИспользования Из РезультатРазметки.МестаИспользования Цикл
		МетаданныеМеста = МестоИспользования.Метаданные;
		
		Если МестоИспользования.ВспомогательныеДанные Тогда
			// Зависимые данные не обрабатываем совсем
			Продолжить;
			
		ИначеЕсли МетаКонстанты.Содержит(МетаданныеМеста) Тогда
			МестоИспользования.КлючЗамены = "Константа";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		Иначе
			ТипДанных = ТипЗнч(МестоИспользования.Данные);
			Если ТипВсеСсылки.СодержитТип(ТипДанных) Тогда
				МестоИспользования.КлючЗамены = "Объект";
				МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
				
			ИначеЕсли ТипКлючЗаписей.СодержитТип(ТипДанных) Тогда
				МестоИспользования.КлючЗамены = "КлючЗаписи";
				МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
				
			Иначе
				// Неизвестный объект для замены ссылок
				Текст = НСтр("ru = 'Неизвестный тип данных %1 для проведения замены %2'");
				Текст = СтрЗаменить(Текст, "%1", Строка(МестоИспользования.Данные));
				Текст = СтрЗаменить(Текст, "%2", Строка(Ссылка));
				РезультатРазметки.ОшибкиРазметки.Добавить(
					Новый Структура("Объект, Текст", МестоИспользования.Данные, Текст));
				
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВКонстанте(Результаты, Знач МестоИспользования, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Константа");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Мета.ПолноеИмя());
	
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке
			Ошибка = НСтр("ru = 'Не удалось заблокировать константу %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
	
	Если СостояниеОперации = "" Тогда
		Менеджер = Константы[Мета.Имя].СоздатьМенеджерЗначения();
		Менеджер.Прочитать();
		
		ЗаменаПроизведена = Истина;
		Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
			Если Менеджер.Значение = Строка.Ссылка Тогда
				Менеджер.Значение = Строка.ЦелеваяСсылка;
				ЗаменаПроизведена = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗаменаПроизведена Тогда
			// Пытаемся сохранить
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(Менеджер, ПараметрыЗаписи);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
				
				// Добавляем запись в результат о ошибке записи
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ДобавитьРезультатЗамены(Результаты, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка)
					);
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;

КонецПроцедуры

Процедура ПроизвестиЗаменуВОбъекте(Результаты, Знач МестоИспользования, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Объект");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ОписаниеПоследовательностей = ОписаниеПоследовательностей(Мета);
	ОписаниеДвижений            = ОписаниеДвижений(Мета);

	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		// Обрабатываем все связные данные одновременно
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		
		// Сам элемент
		Блокировка.Добавить(Мета.ПолноеИмя()).УстановитьЗначение("Ссылка", Данные);
		
		// Движения 
		Для Каждого Элемент Из ОписаниеДвижений Цикл
			// Все по регистратору
			Блокировка.Добавить(Элемент.ПространствоБлокировки + ".НаборЗаписей").УстановитьЗначение("Регистратор", Данные);
			
			// Все кандидаты - измерения для сохранения итогов
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из ОбрабатываемыеСтроки Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.Ссылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		// Последовательности
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", Данные);
			
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из ОбрабатываемыеСтроки Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, ТекущаяСсылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке
			Ошибка = НСтр("ru = 'Не удалось заблокировать один или несколько объектов из списка
			                    |%1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ОписаниеСпискаБлокировки(Блокировка));
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ДобавитьРезультатЗамены(Результаты, Строка.Ссылка, 
					ОписаниеОшибкиЗамены("ОшибкаБлокировки", Данные, ПредставлениеДанных, Ошибка)
				);
			КонецЦикла;
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
	
	Если СостояниеОперации = "" Тогда
		ОбъектыЗаписи = ИзмененныеОбъектыПриЗаменеВОбъекте(Данные, ОбрабатываемыеСтроки, ОписаниеДвижений, ОписаниеПоследовательностей);
		
		// Пытаемся сохранить, сам объект идет последним
		Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
		
		Попытка
			Если ПараметрыЗаписи.НеПроверять Тогда
				// Запись без контроля бизнес-логики
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, ПараметрыЗаписи);
				КонецЦикла;
				
			Иначе
				// Первая запись без контроля- чтобы устранить циклические ссылки
				ПараметрыЗаписи.НеПроверять = Истина;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, ПараметрыЗаписи);
				КонецЦикла;
				
				// Вторая запись c контролем
				ПараметрыЗаписи.НеПроверять = Ложь;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, ПараметрыЗаписи);
				КонецЦикла;
			КонецЕсли;
			
		Исключение
			// Сохраняем причину
			Информация = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
				УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
				
			ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
			Если ПустаяСтрока(ОписаниеОшибки) Тогда
				ОписаниеОшибки = Информация.Описание;
			КонецЕсли;
			
			// Добавляем запись в результат о ошибке записи
			Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ДобавитьРезультатЗамены(Результаты, Строка.Ссылка, 
					ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка)
				);
			КонецЦикла;
			
			СостояниеОперации = "ОшибкаЗаписи";
		КонецПопытки;
		
		Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
		
		// Удаляем обработанные движения и последовательности из таблицы поиска
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВНаборе(Результаты, Знач МестоИспользования, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "КлючЗаписи");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ОписаниеНабора = ОписаниеКлючаЗаписи(Мета);
	НаборЗаписей = ОписаниеНабора.НаборЗаписей;
	
	ПарыЗамен = Новый Соответствие;
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(Строка.Ссылка, Строка.ЦелеваяСсылка);
	КонецЦикла;
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		// Блокировка и подготовка набора
		Блокировка = Новый БлокировкаДанных;
		Для Каждого КлючЗначение Из ОписаниеНабора.СписокИзмерений Цикл
			ТипИзмерения = КлючЗначение.Значение;
			Имя          = КлючЗначение.Ключ;
			Значение     = Данные[Имя];
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ТекущаяСсылка = Строка.Ссылка;
				Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
					Блокировка.Добавить(ОписаниеНабора.ПространствоБлокировки).УстановитьЗначение(Имя, ТекущаяСсылка);
				КонецЕсли;
			КонецЦикла;
			
			НаборЗаписей.Отбор[Имя].Установить(Значение);
		КонецЦикла;
		
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке
			Ошибка = НСтр("ru = 'Не удалось заблокировать набор  %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
		
	Если СостояниеОперации = "" Тогда
		НаборЗаписей.Прочитать();
		ЗаменитьВКоллекцииСтрок(НаборЗаписей, ОписаниеНабора.СписокПолей, ПарыЗамен);
		
		Если НаборЗаписей.Модифицированность() Тогда
			// Пытаемся сохранить
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(НаборЗаписей, ПараметрыЗаписи);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
					
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				// Добавляем запись в результат о ошибке записи
				Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ДобавитьРезультатЗамены(Результаты, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка)
					);
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Функция ИзмененныеОбъектыПриЗаменеВОбъекте(Знач Данные, Знач ОбрабатываемыеСтроки, Знач ОписаниеДвижений, Знач ОписаниеПоследовательностей)
	УстановитьПривилегированныйРежим(Истина);
	
	// Возвращаем измененные обработанные объекты
	Измененные = Новый Соответствие;
	
	// Считываем
	Описание = ОписаниеОбъекта(Данные.Метаданные());
	Попытка
		Объект = Данные.ПолучитьОбъект();
	Исключение
		// Был уже обработан с ошибками
		Объект = Неопределено;
	КонецПопытки;
	
	Если Объект = Неопределено Тогда
		Возврат Измененные;
	КонецЕсли;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ОписаниеДвижения.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеДвижения.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ОписаниеПоследовательности.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеПоследовательности.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	// Заменяем сразу все варианты
	ПарыЗамен = Новый Соответствие;
	Для Каждого МестоИспользования Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(МестоИспользования.Ссылка, МестоИспользования.ЦелеваяСсылка);
	КонецЦикла;
	
	// Реквизиты
	Для Каждого КлючЗначение Из Описание.Реквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
		
	// Стандартные реквизиты
	Для Каждого КлючЗначение Из Описание.СтандартныеРеквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
		
	// Табличные части
	Для Каждого Элемент Из Описание.ТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(Объект[Элемент.Имя], Элемент.СписокПолей, ПарыЗамен);
	КонецЦикла;
	
	// Стандартные табличные части
	Для Каждого Элемент Из Описание.СтандартныеТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(Объект[Элемент.Имя], Элемент.СписокПолей, ПарыЗамен);
	КонецЦикла;
		
	// Движения
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ЗаменитьВКоллекцииСтрок(ОписаниеДвижения.НаборЗаписей, ОписаниеДвижения.СписокПолей, ПарыЗамен);
	КонецЦикла;
	
	// Последовательности
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ЗаменитьВКоллекцииСтрок(ОписаниеПоследовательности.НаборЗаписей, ОписаниеПоследовательности.СписокПолей, ПарыЗамен);
	КонецЦикла;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		Если ОписаниеДвижения.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеДвижения.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		Если ОписаниеПоследовательности.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеПоследовательности.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Сам объект последний - для возможного перепроведения
	Если Объект.Модифицированность() Тогда
		Измененные.Вставить(Объект, Описание.МожетБытьПроведен);
	КонецЕсли;
	
	Возврат Измененные;
КонецФункции

Процедура УдалитьСсылкиПометкой(РезультатУдаления, Знач СписокСсылок, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(РезультатУдаления, СписокСсылок, ПараметрыЗаписи, ВнутренняяТранзакция, Ложь);
	
КонецПроцедуры

Процедура УдалитьСсылкиНепосредственно(РезультатУдаления, Знач СписокСсылок, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(РезультатУдаления, СписокСсылок, ПараметрыЗаписи, ВнутренняяТранзакция, Истина);
	
КонецПроцедуры

Процедура УдалитьСсылкиНемонопольно(РезультатУдаления, Знач СписокСсылок, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция, Знач УдалятьНепосредственно)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Удаляемые = Новый Массив;
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
	КонецЕсли;
		
	Для Каждого Ссылка Из СписокСсылок Цикл
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Ссылка.Метаданные().ПолноеИмя()).УстановитьЗначение("Ссылка", Ссылка);
		
		ПредставлениеСсылки = Строка(Ссылка);
		
		Попытка 
			Блокировка.Заблокировать();
			Удаляемые.Добавить(Ссылка);
		Исключение
			ДобавитьРезультатЗамены(РезультатУдаления, Ссылка, 
				ОписаниеОшибкиЗамены("ОшибкаБлокировки", Ссылка, ПредставлениеСсылки, НСтр("ru = 'Ошибка блокирования ссылки для удаления'"))
			);
		КонецПопытки
	КонецЦикла;
		
	ТаблицаПоиска = МестаИспользования(Удаляемые);
	Фильтр = Новый Структура("Ссылка");
	
	Для Каждого Ссылка Из Удаляемые Цикл
		ПредставлениеСсылки = Строка(Ссылка);
		
		Фильтр.Ссылка = Ссылка;
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(Фильтр);
		
		Индекс = МестаИспользования.ВГраница();
		Пока Индекс >= 0 Цикл
			Если МестаИспользования[Индекс].ВспомогательныеДанные Тогда
				МестаИспользования.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Если МестаИспользования.Количество() > 0 Тогда
			// Был изменен, нельзя удалять
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(РезультатУдаления, МестаИспользования);
			Продолжить;
		КонецЕсли;
		
		Объект = Ссылка.ПолучитьОбъект();
		Если Объект = Неопределено Тогда
			// Уже удален
			Продолжить;
		КонецЕсли;
			
		Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
			
		Попытка
			Если УдалятьНепосредственно Тогда
				ОбработатьОбъектСПерехватомСообщений(Объект, "НепосредственноеУдаление", Неопределено, ПараметрыЗаписи);
			Иначе
				ОбработатьОбъектСПерехватомСообщений(Объект, "ПометкаУдаления", Неопределено, ПараметрыЗаписи);
			КонецЕсли;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ДобавитьРезультатЗамены(РезультатУдаления, Ссылка, 
				ОписаниеОшибкиЗамены("ОшибкаУдаления", Ссылка, ПредставлениеСсылки,
				НСтр("ru = 'Ошибка удаления'") + Символы.ПС + СокрЛП( КраткоеПредставлениеОшибки(ИнформацияОбОшибке)))
			);
		КонецПопытки;
			
		Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
	КонецЦикла;
	
	Если ВнутренняяТранзакция Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
КонецПроцедуры

Процедура ДобавитьРезультатыЗаменыИзмененныхОбъектов(ИтоговаяТаблица, ТаблицаПовторногоПоиска)
	
	ТипКлючЗаписи = ОписаниеТипаКлючиЗаписей();
	
	Фильтр = Новый Структура("ТипОшибки, Ссылка, ОбъектОшибки", "");
	Для Каждого Строка Из ТаблицаПовторногоПоиска Цикл
		Тест = Новый Структура("ВспомогательныеДанные", Ложь);
		ЗаполнитьЗначенияСвойств(Тест, Строка);
		Если Тест.ВспомогательныеДанные Тогда
			Продолжить;
		КонецЕсли;
		
		Данные = Строка.Данные;
		Ссылка = Строка.Ссылка;
		
		ПредставлениеДанных = Строка(Данные);
		
		Фильтр.ОбъектОшибки = Данные;
		Фильтр.Ссылка       = Ссылка;
		Если ИтоговаяТаблица.НайтиСтроки(Фильтр).Количество() = 0 Тогда
			ДобавитьРезультатЗамены(ИтоговаяТаблица, Ссылка, 
				ОписаниеОшибкиЗамены("ДанныеИзменены", Данные, ПредставлениеДанных,
				НСтр("ru = 'Данные были добавлены или изменены другим пользователем'"))
			);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ОписаниеИзмеренийНабора(Знач Мета, Кэш)
	
	ОписаниеИзмерений = Кэш[Мета];
	Если ОписаниеИзмерений<>Неопределено Тогда
		Возврат ОписаниеИзмерений;
	КонецЕсли;
	
	// Период и регистратор, если есть
	ОписаниеИзмерений = Новый Структура;
	
	ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип", Ложь);
	
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		// Возможно есть период
		МетаПериод = Мета.ПериодичностьРегистраСведений; 
		Периодичность = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений;
		
		Если МетаПериод = Периодичность.ПозицияРегистратора Тогда
			ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
			ДанныеИзмерения.Представление = НСтр("ru='Регистратор'");
			ДанныеИзмерения.Ведущее       = Истина;
			ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Год Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.День Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=D; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Квартал Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        =  "Л=ru_RU; ДФ='к ""квартал ""yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Месяц Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='ММММ yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Секунда Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=DT; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		КонецЕсли;
		
	Иначе
		ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
		ДанныеИзмерения.Представление = НСтр("ru='Регистратор'");
		ДанныеИзмерения.Ведущее       = Истина;
		ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
		
	КонецЕсли;
	
	// Все измерения
	Для Каждого МетаИзмерение Из Мета.Измерения Цикл
		ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип");
		ДанныеИзмерения.Тип           = МетаИзмерение.Тип;
		ДанныеИзмерения.Представление = МетаИзмерение.Представление();
		ДанныеИзмерения.Ведущее       = МетаИзмерение.Ведущее;
		ОписаниеИзмерений.Вставить(МетаИзмерение.Имя, ДанныеИзмерения);
	КонецЦикла;
	
	Кэш[Мета] = ОписаниеИзмерений;
	Возврат ОписаниеИзмерений;
КонецФункции

Функция ОписаниеДвижений(Знач Мета)
	// можно закэшировать по Мета
	
	ОписаниеДвижений = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеДвижений;
	КонецЕсли;
	
	Для Каждого Движение Из Мета.Движения Цикл
		
		Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыНакопления[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыСведений[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыБухгалтерии[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыРасчета[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, БазовыйПериодКонец, БазовыйПериодНачало, НомерСтроки, ПериодДействия,
			                |ПериодДействияКонец, ПериодДействияНачало, ПериодРегистрации, Регистратор, Сторно,
			                |ФактическийПериодДействия";
		Иначе
			// Неизвестный тип
			Продолжить;
		КонецЕсли;
		
		// Поля ссылочного типа и измерения - кандидаты
		Описание = СпискиПолейПоТипу(НаборЗаписей, Движение.Измерения, ИсключатьПоля);
		Если Описание.СписокПолей.Количество() = 0 Тогда
			// Незачем обрабатывать
			Продолжить;
		КонецЕсли;
		
		Описание.Вставить("НаборЗаписей", НаборЗаписей);
		Описание.Вставить("ПространствоБлокировки", Движение.ПолноеИмя() );
		
		ОписаниеДвижений.Добавить(Описание);
	КонецЦикла;	// Метаданные движений
	
	Возврат ОписаниеДвижений;
КонецФункции

Функция ОписаниеПоследовательностей(Знач Мета)
	
	ОписаниеПоследовательностей = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеПоследовательностей;
	КонецЕсли;
	
	Для Каждого Последовательность Из Метаданные.Последовательности Цикл
		Если Не Последовательность.Документы.Содержит(Мета) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТаблицы = Последовательность.ПолноеИмя();
		
		// Список полей и измерений
		Описание = СпискиПолейПоТипу(ИмяТаблицы, Последовательность.Измерения, "Регистратор");
		Если Описание.СписокПолей.Количество() > 0 Тогда
			
			Описание.Вставить("НаборЗаписей",           Последовательности[Последовательность.Имя].СоздатьНаборЗаписей());
			Описание.Вставить("ПространствоБлокировки", ИмяТаблицы + ".Записи");
			Описание.Вставить("Измерения",              Новый Структура);
			
			ОписаниеПоследовательностей.Добавить(Описание);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОписаниеПоследовательностей;
КонецФункции

Функция ОписаниеОбъекта(Знач Мета)
	// можно закэшировать по Мета
	
	ТипВсеСсылки = ОписаниеТипаВсеСсылки();
	
	Кандидаты = Новый Структура("Реквизиты, СтандартныеРеквизиты, ТабличныеЧасти, СтандартныеТабличныеЧасти");
	ЗаполнитьЗначенияСвойств(Кандидаты, Мета);
	
	ОписаниеОбъекта = Новый Структура;
	
	ОписаниеОбъекта.Вставить("Реквизиты", Новый Структура);
	Если Кандидаты.Реквизиты <> Неопределено Тогда
		Для Каждого МетаРеквизит Из Кандидаты.Реквизиты Цикл
			Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеРеквизиты", Новый Структура);
	Если Кандидаты.СтандартныеРеквизиты <> Неопределено Тогда
		Исключаемые = Новый Структура("Ссылка");
		
		Для Каждого МетаРеквизит Из Кандидаты.СтандартныеРеквизиты Цикл
			Имя = МетаРеквизит.Имя;
			Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("ТабличныеЧасти", Новый Массив);
	Если Кандидаты.ТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.ТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.Реквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.ТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеТабличныеЧасти", Новый Массив);
	Если Кандидаты.СтандартныеТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.СтандартныеТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.СтандартныеРеквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.СтандартныеТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("МожетБытьПроведен", Метаданные.Документы.Содержит(Мета));
	Возврат ОписаниеОбъекта;
КонецФункции

Функция ОписаниеКлючаЗаписи(Знач Мета)
	// можно закэшировать по Мета
	
	ИмяТаблицы = Мета.ПолноеИмя();
	
	// Поля ссылочного типа - кандидаты и набор измерений
	ОписаниеКлюча = СпискиПолейПоТипу(ИмяТаблицы, Мета.Измерения, "Период, Регистратор");
		
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыСведений[Мета.Имя].СоздатьНаборЗаписей();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыНакопления[Мета.Имя].СоздатьНаборЗаписей();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыБухгалтерии[Мета.Имя].СоздатьНаборЗаписей();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыРасчета[Мета.Имя].СоздатьНаборЗаписей();
		
	Иначе
		НаборЗаписей = Неопределено;
	КонецЕсли;
		
	ОписаниеКлюча.Вставить("НаборЗаписей", НаборЗаписей);
	ОписаниеКлюча.Вставить("ПространствоБлокировки", ИмяТаблицы);

	Возврат ОписаниеКлюча;
КонецФункции

Функция ОписаниеСпискаБлокировки(Знач Блокировка)
	// Только уникальные значения
	Обработанные = Новый Соответствие;
	
	СтрокаОписания = "";
	Для Каждого Элемент Из Блокировка Цикл
		Для Каждого Поле Из Элемент.Поля Цикл
			Значение = Поле.Значение;
			Если Обработанные[Значение] = Неопределено Тогда
				СтрокаОписания = СтрокаОписания + Символы.ПС + Поле.Значение;
				Обработанные[Значение] = Истина;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат СокрЛ(СтрокаОписания);
КонецФункции

Функция ОписанияТиповПересекаются(Знач Описание1, Знач Описание2)
	
	Для Каждого Тип Из Описание1.Типы() Цикл
		Если Описание2.СодержитТип(Тип) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

// Возвращает описание по имени таблицы или по набору записей
Функция СпискиПолейПоТипу(Знач ИсточникДанных , Знач МетаИзмерения, Знач ИсключатьПоля)
	// можно закэшировать
	
	Описание = Новый Структура;
	Описание.Вставить("СписокПолей",     Новый Структура);
	Описание.Вставить("СписокИзмерений", Новый Структура);
	Описание.Вставить("СписокВедущих",   Новый Структура);
	
	ТипКонтроля = ОписаниеТипаВсеСсылки();
	Исключаемые = Новый Структура(ИсключатьПоля);
	
	ТипИсточникаДанных = ТипЗнч(ИсточникДанных);
	
	Если ТипИсточникаДанных = Тип("Строка") Тогда
		// Источник - имя таблицы, получаем поля запросом
		Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ " + ИсточникДанных + " ГДЕ ЛОЖЬ");
		ИсточникПолей = Запрос.Выполнить();
	Иначе
		// Источник - набор записей
		ИсточникПолей = ИсточникДанных.ВыгрузитьКолонки();
	КонецЕсли;
	
	Для Каждого Колонка Из ИсточникПолей.Колонки Цикл
		Имя = Колонка.Имя;
		Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(Колонка.ТипЗначения, ТипКонтроля) Тогда
			Описание.СписокПолей.Вставить(Имя);
			
			// И проверка на ведущее измерение
			Мета = МетаИзмерения.Найти(Имя);
			Если Мета <> Неопределено Тогда
				Описание.СписокИзмерений.Вставить(Имя, Мета.Тип);
				Тест = Новый Структура("Ведущее", Ложь);
				ЗаполнитьЗначенияСвойств(Тест, Мета);
				Если Тест.Ведущее Тогда
					Описание.СписокВедущих.Вставить(Имя, Мета.Тип);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Описание;
КонецФункции

Процедура ДобавитьРезультатЗамены(Таблица, Знач Ссылка, Знач ОписаниеОшибки)
	Строка = Таблица.Добавить();
	
	Строка.Ссылка = Ссылка;
	
	Строка.ПредставлениеОбъектаОшибки = ОписаниеОшибки.ПредставлениеОбъектаОшибки;
	Строка.ОбъектОшибки               = ОписаниеОшибки.ОбъектОшибки;
	Строка.ТекстОшибки                = ОписаниеОшибки.ТекстОшибки;
	Строка.ТипОшибки                  = ОписаниеОшибки.ТипОшибки;
	
КонецПроцедуры

Функция ОписаниеОшибкиЗамены(Знач ТипОшибки, Знач ОбъектОшибки, Знач ПредставлениеОбъектаОшибки, Знач ТекстОшибки)
	Результат = Новый Структура;
	
	Результат.Вставить("ТипОшибки",                  ТипОшибки);
	Результат.Вставить("ОбъектОшибки",               ОбъектОшибки);
	Результат.Вставить("ПредставлениеОбъектаОшибки", ПредставлениеОбъектаОшибки);
	Результат.Вставить("ТекстОшибки",                ТекстОшибки);
	
	Возврат Результат;
КонецФункции

Процедура ЗаменитьВКоллекцииСтрок(Коллекция, Знач СписокПолей, Знач ПарыЗамен)
	РабочаяКоллекция = Коллекция.Выгрузить();
	Модифицировано = Ложь;
	
	Для Каждого Строка Из РабочаяКоллекция Цикл
		
		Для Каждого КлючЗначение Из СписокПолей Цикл
			Имя = КлючЗначение.Ключ;
			ЦелеваяСсылка = ПарыЗамен[ Строка[Имя] ];
			Если ЦелеваяСсылка <> Неопределено Тогда
				Строка[Имя] = ЦелеваяСсылка;
				Модифицировано = Истина;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Если Модифицировано Тогда
		Коллекция.Загрузить(РабочаяКоллекция);
	КонецЕсли;
КонецПроцедуры

Процедура СообщитьОтложенныеСообщения(Знач Сообщения)
	
	Для Каждого Сообщение Из Сообщения Цикл
		Сообщение.Сообщить();
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьОбъектСПерехватомСообщений(Знач Объект, Знач Действие, Знач РежимЗаписи, Знач ПараметрыЗаписи)
	
	// Текущие сообщения до исключения запоминаем
	ПредыдущиеСообщения = ПолучитьСообщенияПользователю(Истина);
	СообщатьПовторно    = ТекущийРежимЗапуска() <> Неопределено;
	
	Попытка
		
		Если Действие = "Запись" Тогда
			УстановитьПараметрыЗаписи(Объект, ПараметрыЗаписи);
			Если РежимЗаписи = Неопределено Тогда
				Объект.Записать();
			Иначе
				Объект.Записать(РежимЗаписи);
			КонецЕсли;
			
		ИначеЕсли Действие = "ПометкаУдаления" Тогда
			УстановитьПараметрыЗаписи(Объект, ПараметрыЗаписи);
			Объект.УстановитьПометкуУдаления(Истина, Ложь);
			
		ИначеЕсли Действие = "НепосредственноеУдаление" Тогда
			УстановитьПараметрыЗаписи(Объект, ПараметрыЗаписи);
			Объект.Удалить();
			
		КонецЕсли;
		
	Исключение
		Информация = ИнформацияОбОшибке(); 
		
		// Перехватываем все сообщенное при ошибке и добавляем их в одно исключение
		ТекстИсключения = "";
		Для Каждого Сообщение Из ПолучитьСообщенияПользователю(Ложь) Цикл
			ТекстИсключения = ТекстИсключения + Символы.ПС + Сообщение.Текст;
		КонецЦикла;
		
		// Сообщаем предыдущие
		Если СообщатьПовторно Тогда
			СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
		КонецЕсли;
		
		ВызватьИсключение СокрЛП(КраткоеПредставлениеОшибки(Информация) + Символы.ПС + СокрЛП(ТекстИсключения));
	КонецПопытки;
	
	Если СообщатьПовторно Тогда
		СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьОбъект(Знач Объект, Знач ПараметрыЗаписи)
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	Если ЭтоДокумент(МетаданныеОбъекта) Тогда
		ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", РежимЗаписиДокумента.Запись, ПараметрыЗаписи);
		Возврат;
	КонецЕсли;
	
	// Проверка на возможные циклические ссылки
	ТестРеквизитов= Новый Структура("Иерархический, ВидыСубконто, Владельцы", Ложь, Неопределено, Новый Массив);
	ЗаполнитьЗначенияСвойств(ТестРеквизитов, МетаданныеОбъекта);
	
	// По родителю
	Если ТестРеквизитов.Иерархический Или ТестРеквизитов.ВидыСубконто <> Неопределено Тогда 
		
		Если Объект.Родитель = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в иерархии.'"),
				Строка(Объект));
			КонецЕсли;
			
	КонецЕсли;
	
	// По владельцу
	Для Каждого МетаВладелец Из ТестРеквизитов.Владельцы Цикл
		
		Если Объект.Владелец = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в подчинении.'"),
				Строка(Объект));
		КонецЕсли;
		Прервать;
		
	КонецЦикла;
	
	// Просто запись
	ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", Неопределено, ПараметрыЗаписи);
КонецПроцедуры

Процедура УстановитьПараметрыЗаписи(Объект, Знач ПараметрыЗаписи)
	
	ТестРеквизита = Новый Структура("ОбменДанными");
	ЗаполнитьЗначенияСвойств(ТестРеквизита, Объект);
	Если ТипЗнч(ТестРеквизита.ОбменДанными) = Тип("ПараметрыОбменаДанными") Тогда
		Объект.ОбменДанными.Загрузка = ПараметрыЗаписи.НеПроверять;
		Объект.ОбменДанными.Получатели.АвтоЗаполнение = Не ПараметрыЗаписи.НеПроверять;
	КонецЕсли;
	
	Объект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов", ПараметрыЗаписи.НеПроверять);
	
КонецПроцедуры

Функция СобытиеЖурналаРегистрацииЗаменыСсылок()
	Возврат НСтр("ru='Поиск и удаление ссылок'", 
		Метаданные.ОсновнойЯзык.КодЯзыка);
КонецФункции

Процедура ЗаменитьСсылкиКороткимиТранзакциями(РезультатЗамены, Знач ПараметрыЗамены, Знач ПроизводимыеЗамены, Знач ТаблицаПоиска)
	
	// Основной цикл обработки
	ПараметрыЗаписи = Новый Структура;
	ПараметрыЗаписи.Вставить("НеПроверять", Не ПараметрыЗамены.КонтрольПриЗаписи);
	ПараметрыЗаписи.Вставить("ПривилегированнаяЗапись", ПараметрыЗамены.ПривилегированнаяЗапись);
	
	ФильтрСсылок = Новый Структура("Ссылка, КлючЗамены");
	Для Каждого Ссылка Из ПроизводимыеЗамены Цикл
		ФильтрСсылок.Ссылка = Ссылка;
		
		ФильтрСсылок.КлючЗамены = "Константа";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВКонстанте(РезультатЗамены, МестоИспользования, ПараметрыЗаписи);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "Объект";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВОбъекте(РезультатЗамены, МестоИспользования, ПараметрыЗаписи);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "КлючЗаписи";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВНаборе(РезультатЗамены, МестоИспользования, ПараметрыЗаписи);
		КонецЦикла;
	КонецЦикла;
	
	// Окончательные действия
	Если ПараметрыЗамены.УдалятьНепосредственно Тогда
		УдалитьСсылкиНепосредственно(РезультатЗамены, ПроизводимыеЗамены, ПараметрыЗаписи, Истина);
		
	ИначеЕсли ПараметрыЗамены.ПомечатьНаУдаление Тогда
		УдалитьСсылкиПометкой(РезультатЗамены, ПроизводимыеЗамены, ПараметрыЗаписи);
		
	Иначе 
		// Поиск новых
		ТаблицаПовторногоПоиска = МестаИспользования(ПроизводимыеЗамены);
		ДобавитьРезультатыЗаменыИзмененныхОбъектов(РезультатЗамены, ТаблицаПовторногоПоиска);
	КонецЕсли;
		
КонецПроцедуры

Процедура ЗаменитьСсылкуДлиннойТранзакцией(РезультатЗамены, Знач Ссылка, Знач ПараметрыЗамены, Знач ТаблицаПоиска)
	УстановитьПривилегированныйРежим(Истина);
	
	ПараметрыЗаписи = Новый Структура;
	ПараметрыЗаписи.Вставить("НеПроверять", Не ПараметрыЗамены.КонтрольПриЗаписи);
	ПараметрыЗаписи.Вставить("ПривилегированнаяЗапись", ПараметрыЗамены.ПривилегированнаяЗапись);
	
	СостояниеОперации = "";
	
	// 1. Блокирование всех мест использования
	Блокировка = Новый БлокировкаДанных;
	
	МестаИспользованияКонстанты = ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка, КлючЗамены", Ссылка, "Константа"));
	ДобавитьОбъектыБлокировкиКонстанты(Блокировка, МестаИспользованияКонстанты);
	
	МестаИспользованияОбъекты = ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка, КлючЗамены", Ссылка, "Объект"));
	ДобавитьОбъектыБлокировкиОбъекты(Блокировка, МестаИспользованияОбъекты);
	
	МестаИспользованияНаборы = ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка, КлючЗамены", Ссылка, "КлючЗаписи"));
	ДобавитьОбъектыБлокировкиНаборы(Блокировка, МестаИспользованияНаборы);
		
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
	Исключение
		// Добавляем запись в результат о неудачной попытке блокировке
		Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось заблокировать все места использования %1'"),
			Ссылка
		);
		ДобавитьРезультатЗамены(РезультатЗамены, Ссылка, 
			ОписаниеОшибкиЗамены("ОшибкаБлокировки", Неопределено, Неопределено, Ошибка)
		);
	
		СостояниеОперации = "ОшибкаБлокировки";
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// 2. Замена везде до первой ошибки
	Если СостояниеОперации = "" Тогда
		КоличествоОшибок = РезультатЗамены.Количество();
		
		Для Каждого МестоИспользования Из МестаИспользованияКонстанты Цикл
			ПроизвестиЗаменуВКонстанте(РезультатЗамены, МестоИспользования, ПараметрыЗаписи, Ложь);
			Если КоличествоОшибок <> РезультатЗамены.Количество() Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если КоличествоОшибок = РезультатЗамены.Количество() Тогда
			Для Каждого МестоИспользования Из МестаИспользованияОбъекты Цикл
				ПроизвестиЗаменуВОбъекте(РезультатЗамены, МестоИспользования, ПараметрыЗаписи, Ложь);
				Если КоличествоОшибок <> РезультатЗамены.Количество() Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если КоличествоОшибок = РезультатЗамены.Количество() Тогда
			Для Каждого МестоИспользования Из МестаИспользованияНаборы Цикл
				ПроизвестиЗаменуВНаборе(РезультатЗамены, МестоИспользования, ПараметрыЗаписи, Ложь);
				Если КоличествоОшибок <> РезультатЗамены.Количество() Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		Иначе
			СостояниеОперации = "ОшибкаЗаписи";
		КонецЕсли;
		
	КонецЕсли;
	
	// 3. Удаление 
	ПроизводимыеЗамены = Новый Массив;
	ПроизводимыеЗамены.Добавить(Ссылка);
	
	Если СостояниеОперации = "" Тогда
		КоличествоОшибок = РезультатЗамены.Количество();
		
		Если ПараметрыЗамены.УдалятьНепосредственно Тогда
			УдалитьСсылкиНепосредственно(РезультатЗамены, ПроизводимыеЗамены, ПараметрыЗаписи, Ложь);
			
		ИначеЕсли ПараметрыЗамены.ПомечатьНаУдаление Тогда
			УдалитьСсылкиПометкой(РезультатЗамены, ПроизводимыеЗамены, ПараметрыЗаписи, Ложь);
			
		Иначе 
			// Поиск новых
			ТаблицаПовторногоПоиска = МестаИспользования(ПроизводимыеЗамены);
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(РезультатЗамены, ТаблицаПовторногоПоиска);
		КонецЕсли;
		
		Если КоличествоОшибок <> РезультатЗамены.Количество() Тогда
			СостояниеОперации = "ДанныеИзменены";
		КонецЕсли;
	КонецЕсли;
	
	Если СостояниеОперации = "" Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли;
	
КонецПроцедуры
	
Процедура ДобавитьОбъектыБлокировкиКонстанты(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого Строка Из СтрокиИспользования Цикл
		Блокировка.Добавить(Строка.Метаданные.ПолноеИмя());
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьОбъектыБлокировкиОбъекты(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого МестоИспользования Из СтрокиИспользования Цикл
		Данные = МестоИспользования.Данные;
		Мета   = МестоИспользования.Метаданные;
		
		// Сам элемент
		Блокировка.Добавить(Мета.ПолноеИмя()).УстановитьЗначение("Ссылка", Данные);
		
		// Движения 
		ОписаниеДвижений = ОписаниеДвижений(Мета);
		Для Каждого Элемент Из ОписаниеДвижений Цикл
			// Все по регистратору
			Блокировка.Добавить(Элемент.ПространствоБлокировки + ".НаборЗаписей").УстановитьЗначение("Регистратор", Данные);
			
			// Все кандидаты - измерения для сохранения итогов
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из СтрокиИспользования Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.Ссылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		// Последовательности
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(Мета);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", Данные);
			
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из СтрокиИспользования Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, ТекущаяСсылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
	
	КонецЦикла;

КонецПроцедуры

Процедура ДобавитьОбъектыБлокировкиНаборы(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого МестоИспользования Из СтрокиИспользования Цикл
		Данные = МестоИспользования.Данные;
		Мета   = МестоИспользования.Метаданные; 
		
		ОписаниеНабора = ОписаниеКлючаЗаписи(Мета);
		НаборЗаписей = ОписаниеНабора.НаборЗаписей;
		
		Для Каждого КлючЗначение Из ОписаниеНабора.СписокИзмерений Цикл
			ТипИзмерения = КлючЗначение.Значение;
			Имя          = КлючЗначение.Ключ;
			Значение     = Данные[Имя];
			
			Для Каждого Строка Из СтрокиИспользования Цикл
				ТекущаяСсылка = Строка.Ссылка;
				Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
					Блокировка.Добавить(ОписаниеНабора.ПространствоБлокировки).УстановитьЗначение(Имя, ТекущаяСсылка);
				КонецЕсли;
			КонецЦикла;
			
			НаборЗаписей.Отбор[Имя].Установить(Значение);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ВычислитьЗначениеДанныхПоПути(Знач Данные, Знач ПутьДанных)
	ЧастиПути = СтрЗаменить(ПутьДанных, ".", Символы.ПС);
	КоличествоЧастейПути = СтрЧислоСтрок(ЧастиПути);
	
	ПромежуточныйРезультат = Данные;
	
	Для Индекс = 1 По КоличествоЧастейПути Цикл
		ИмяРеквизита = СтрПолучитьСтроку(ЧастиПути, Индекс);
		
		Тест = Новый Структура(ИмяРеквизита, Неопределено);
		ЗаполнитьЗначенияСвойств(Тест, ПромежуточныйРезультат);
		Если Тест[ИмяРеквизита] = Неопределено Тогда
			Тест[ИмяРеквизита] = -1;
			ЗаполнитьЗначенияСвойств(Тест, ПромежуточныйРезультат);
			Если Тест[ИмяРеквизита] = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Ошибка вычисления %1 для объекта %2. Реквизит %3 не найден'"),
					ПутьДанных, Данные, ИмяРеквизита 
				);
			КонецЕсли;
		КонецЕсли;
		
		Результат = Тест[ИмяРеквизита];
		Если Индекс = КоличествоЧастейПути Тогда
			Возврат Результат;
			
		ИначеЕсли Результат = Неопределено Тогда
			// Не можем дальше считать
			Возврат Неопределено;
			
		КонецЕсли;
		
		ПромежуточныйРезультат = Результат;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

// Служебная. Запускает фоновые задания при замене ссылок.
Процедура ФоновыйРасчетКоличестваВхождений(Знач НаборСсылок, Знач АдресРезультата) Экспорт
	
	ТаблицаПоиска = МестаИспользования(НаборСсылок);
	
	Фильтр = Новый Структура("ВспомогательныеДанные", Ложь);
	АктуальныеСтроки = ТаблицаПоиска.НайтиСтроки(Фильтр);
	
	Результат = ТаблицаПоиска.Скопировать(АктуальныеСтроки, "Ссылка");
	Результат.Колонки.Добавить("Вхождения", Новый ОписаниеТипов("Число"));
	Результат.ЗаполнитьЗначения(1, "Вхождения");
	
	Результат.Свернуть("Ссылка", "Вхождения");
	Для Каждого Ссылка Из НаборСсылок Цикл
		Если Результат.Найти(Ссылка, "Ссылка") = Неопределено Тогда
			Результат.Добавить().Ссылка = Ссылка;
		КонецЕсли;
	КонецЦикла;
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
КонецПроцедуры

// См. Обработка.ПоискИУдалениеДублей
Функция ДоступныеИменаМетаРеквизитовОтбора(Знач МетаКоллекция)
	Результат = "";
	ТипХранилища = Тип("ХранилищеЗначения");
	
	Для Каждого МетаРеквизит Из МетаКоллекция Цикл
		ЭтоХранилище = МетаРеквизит.Тип.СодержитТип(ТипХранилища);
		Если Не ЭтоХранилище Тогда
			Результат = Результат + "," + МетаРеквизит.Имя;
		КонецЕсли
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

#КонецОбласти
